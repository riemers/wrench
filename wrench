#!/bin/bash
# wrench
# v2.01
#
# A Steam Source Dedicated Server (srcds) control system.
# For use with Valve's Source game servers: TF2, L4D, L4D2, HL2DM, CSS, CSGO, and more.
#
# --
# Set PATH as is apropriate for your system. Mostly we need this for cron usage, otherwise possibly not needed.
PATH=~/bin:~/script:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin
# --
USER=$(whoami)
MYNAME=$(basename $0)
MYSELF=$(readlink -f $0)
RUNID=$(date +%Y%m%d%H%M%S)-$$
MYPID=$$
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# Read in config file
. $DIR/.config

MAILER=mail
SQLITE=sqlite3
SQLCMD="sqlite3 -batch -list -noheader $SQLDBFILE"
SQLSHOWCMD="sqlite3 -batch -line -noheader $SQLDBFILE"
NICECMD="nice -n 11 ionice -c 2 -n 6"
AUTOUPDATE_LOCKFILE="/tmp/${MYNAME}-${USER}-autoupdate.pid"
AUTOUPDATE_LOGDIR=$APPDIR/autoupdate-logs
AUTOUPDATE_LOGFILE=$AUTOUPDATE_LOGDIR/$(basename $0 .sh)_autoupdate-${RUNID}.log
MAIL_SUBJ_PREFIX="WRENCH:"
# --

echoerr() {
	# Print errors to stderr.
	echo "$@" 1>&2;
	if [[ -n "$SEEN_ERROR" ]] ; then declare -r SEEN_ERROR=1 ; fi # If we saw any errors, set SEEN_ERROR=1, for later use.
}

f_cleanuptrap() {
	# Cleanup trap.
	#
	unset MYPID_CHILDREN
	local MYPID_CHILDREN MYPID_BAD_CHILDREN X_CKILL_TIMEOUT
	#
	echoerr ""
	echoerr "Caught signal."
	#
	# Find and kill off all child processes which might be running.
	MYPID_CHILDREN=$(pgrep -P $MYPID 2> /dev/null)
	if [[ -n "$MYPID_CHILDREN" ]] ; then
		# echoerr "DEBUG: Killing child processes: $(echo $MYPID_CHILDREN | tr -d "\n")"
		for EACH in $MYPID_CHILDREN ; do
			kill "$EACH" &> /dev/null
		done ; unset EACH
		# Give these processes 3 seconds to die by SIGTERM before we KILL them.
		# This does not work because wait is a bash built-in. # timeout 3 wait "$MYPID_CHILDREN" ; X_CKILL_TIMEOUT=$?
		# Should not need this anyway.
		# if [[ "$X_CKILL_TIMEOUT" == 124 ]] ; then
		# 	MYPID_BAD_CHILDREN=$(pgrep -P $MYPID)
		#	# echoerr "DEBUG: Killing bad child processes: $(echo $MYPID_BAD_CHILDREN | tr -d "\n")"
		#	for EACH in $MYPID_BAD_CHILDREN; do
		#		kill -s SIGKILL "$EACH" &> /dev/null
		#	done ; unset EACH
		#fi
	fi
	#
	echoerr -n "Cleaning up: "
	# Remove the update lock file, if we need to, and if it is there
	if [[ "$UPDATING" == 1 ]] ; then # Cleanup during an update.
		[[ -f "$LOCKFILE" ]] && rm -f "$LOCKFILE" &> /dev/null
		f_lockdownmaster # Lock the master after an aborted update.
	fi
	if [[ "$AUTOUPDATING" == 1 ]] ; then # Cleanup during an auto-update.
		[[ -f "$AUTOUPDATE_LOCKFILE" ]] && rm -f "$AUTOUPDATE_LOCKFILE" &> /dev/null
		# Should we really be deleting the log file?
		# [[ -f "$AUTOUPDATE_LOGFILE" ]] && rm -f "$AUTOUPDATE_LOGFILE" &> /dev/null
	fi
	if [[ "$LISTINGPLAYERS" == 1 ]] ; then # Cleanup when listing players.
		find /tmp -maxdepth 1 -type p -name "qstat-out-*$RUNID" -exec rm -f '{}' + &> /dev/null
	fi
	#
	# We should restore the tty line settings, because traping while at a read prompt can cause problems for the user terminal.
	# This turned out to be a bash bug: https://lists.gnu.org/archive/html/help-bash/2014-06/msg00006.html
	if [[ -n "$TTY_LINE_SETTINGS" ]] ; then
		# echoerr "DEBUG: Restored stty line settings."
		stty "$TTY_LINE_SETTINGS"
	fi
	#
	echoerr "Done"
	echoerr ""
}

f_getpid() {
	# Get the current PID of an installation, if there is one, and record the server's operational status.
	# Operational status (RUNSTATUS) can be one of "running", "stopped", "crashed", or "error".
	# We return exit 1 on error, otherwise 0.
	# f_getpid should never send stdout or stderr, unless debugging.
	#
	unset GAMESERVPID RUNSTATUS
	#
	# We should know where to look up the PIDFILE. If we don't, that's a serious problem.
	if [[ -z "$PIDFILE" ]] ; then
		# echoerr "DEBUG: Call to obtain PID, but PIDFILE not set."
		GAMESERVPID=""
		RUNSTATUS="error"
		return 1
	fi
	# Bad things that could possibly happen include the PID file being missing, the process being missing, or the tmux session being missing.
	if [[ -r "$PIDFILE" ]] ; then
		# declare -i GAMESERVPID=$(cat $PIDFILE) # This fails! I guess the data is seen as a string?
		GAMESERVPID=$(cat $PIDFILE | egrep -m 1 -o "^[0-9]+$" )
		# Make sure the process is not crashed.
		# Note that we use SRCDS_LINUX as the name of the process here for validation. This may be incompatible with mods, and non-srcds_linux platforms.
		if [[ -n "$GAMESERVPID" ]] && [[ "$(ps --no-headers -p $GAMESERVPID -o comm)" == "$SRCDS_LINUX" ]] && [[ -z "$(ps --no-headers -p $GAMESERVPID -o pid)" ]] ; then
			GAMESERVPID=""
			RUNSTATUS="crashed"
		else
			RUNSTATUS="running"
		fi
		# We don't bother to check on the tmux session, because it is very unlikely that the process could be running without tmux as it's parent.
	# It is also possible that the PIDFILE is missing, but the tmux session is running. The process may or may not also be running.
	# In theory, the only time this should happen is when the server is just starting up, or if the STARTBIN/SRCDS_LINUX has failed.
	elif ( tmux has-session -t $INSTALLID 2> /dev/null ) ; then
		# echoerr "DEBUG: TMUX session exists, but there is no PIDFILE."
		GAMESERVPID=""
		RUNSTATUS="error"
		return 1
	# If there is no PIDFILE and no tmux session, then it's good to assume that the server is stopped.
	else
		GAMESERVPID=""
		RUNSTATUS="stopped"
	fi
	#
	# echoerr "DEBUG: PIDFILE=$PIDFILE"
	# echoerr "DEBUG: GAMESERVPID=$GAMESERVPID"
	# echoerr "DEBUG: RUNSTATUS=$RUNSTATUS"
}

f_quitifrunning() {
	# For certain activities, we don't want to proceed if the installation is actively running.
	# We set RUNQUIT=1, and the parent func uses that to exit/return as needed.
	#
	unset RUNQUIT
	local X_GETPID
	#
    if [[ "$INSTALLID" == "all" ]] ; then
		return
	fi
	f_getpid ; X_GETPID="$?"
	if [[ "$RUNSTATUS" == "stopped" ]] ; then
		return 0
    elif [[ "$RUNSTATUS" == "running" && "$IN_PARAMS" == *"force" ]] ; then
		RUNQUIT=1
		echoerr ""
		echoerr "FORCE: Installation $INSTALLID is running but will be ignored"
		echoerr ""
		return 1
	elif [[ "$RUNSTATUS" == "running" ]] ; then
		RUNQUIT=1
		echoerr ""
		echoerr "ERROR: Installation $INSTALLID appears to be running."
		echoerr "  Unable to continue."
		echoerr ""
		return 1
	elif [[ "$RUNSTATUS" == "crashed" ]] ; then
		RUNQUIT=1
		echoerr ""
		echoerr "ERROR: Installation $INSTALLID appears to have crashed."
		echoerr "  Recommended course of action is to remove the PID file after making sure the process is really dead."
		echoerr "  You may also run the \"$MYNAME stop\" command, and the situation should get cleaned up automatically."
		echoerr "  PIDFILE=$PIDFILE, PID: $GAMESERVPID"
		echoerr "  Unable to continue."
		echoerr ""
		return 1
	else
		RUNQUIT=1
		echoerr ""
		echoerr "ERROR: Unable to get the installation's current operational status."
		echoerr "  This may be a temporary error, or because the process has failed."
		echoerr "  Unable to continue."
		echoerr ""
		return 1
	fi
}

f_qstat() {
	# qstat replacement function. Mostly because of 0.0.0.0 addresses.
	#
	local QSTAT_PARAMS QSTAT_IPADDR
	#
	QSTAT_PARAMS="$@"
	if [[ "$IPADDR" == "0.0.0.0" ]] ; then
		# We need to replace 0.0.0.0 with a real local IP address.
		# This has been tested on multiple hosts. I hope it works everywhere.
		QSTAT_IPADDR=$(ip route get 8.8.8.8 | egrep -o "src [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | cut -f 2 -d " ")
		QSTAT_PARAMS="$(echo $QSTAT_PARAMS | sed -e "s/0\.0\.0\.0/$QSTAT_IPADDR/")"
	fi
	$QSTAT_CMD $QSTAT_PARAMS
}

f_start() {
	# Start an installation.
	#
	unset EXPORT_VARS
	local X_TMUXSTART X_RENICE STARTUP_CAPTURE_PANE_FILE EVALTXT_START_CMD FQP_STARTBIN
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	f_mailnotify start "Server start request received."
	#
	# TEMP: Warn user if they are using the HLDSID var in their STARTBINARGS.
	if ( echo "$DB_STARTBINARGS" | egrep '\$HLDSID' &> /dev/null) ; then
		echoerr ""
		echoerr "WARNING: Installation \"$IN_INSTALLID\" STARTBINARGS includes the \"HLDSID\" parameter."
		echoerr "  The HLDSID parameter is deprecidated and will be removed in a future version of $MYNAME."
		echoerr "  If you are using HLDSID as the \"-game\" argument, you should use \"GAMEARG\" instead."
		echoerr "  Use the \"$MYNAME reconfig $IN_INSTALLID\" command to change your STARTBINARGS."
		echoerr ""
	fi
	#
	# Never allow a master type server to start.
	if [[ "$INSTTYPE" == master ]] ; then
		echoerr ""
		echoerr "ERROR: $INSTALLID is a master type installation. Master type installations can not be started."
		echoerr ""
		return 1
	fi
	# Do not start if ALLOWSTART is not set.
	if [[ ! "$ALLOWSTART" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: $INSTALLID configuration option ALLOWSTART is set to disallow starting."
		echoerr ""
		return 1
	fi
	# Find out if server is already running, and error out if true.
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 ]] ; then return 1 ; fi
	# FIXME: We need a way to mark installations as linked/delinked. The best place to do this would be the DB inst table.
	# Validate that STARTBIN and SRCDS_LINUX is valid.
	if ( [[ "$STARTBIN" == srcds_run ]] && [[ ! -x "$BINDIR/$STARTBIN" ]] ) || ( ! [[ "$STARTBIN" == srcds_run ]] && ! (type "$STARTBIN" &> /dev/null) ) ; then
		echoerr ""
		echoerr "ERROR: The STARTBIN, \"$STARTBIN\", is not executable or can not be found."
		# echoerr "  DEBUG: PATH=$PATH"
		echoerr ""
		return 1
	fi
	if [[ ! -x "$BINDIR/$SRCDS_LINUX" ]] ; then
		echoerr ""
		echoerr "ERROR: The SRCDS_LINUX, \"$SRCDS_LINUX\", is not executable or can not be found."
		echoerr ""
		return 1
	fi
	# Check for an update lock.
	f_lockcheck
	if [[ "$LOCKFAIL" == 1 ]] ; then return 1 ; fi
	# Warn if the server has no autoexec.cfg, no server.cfg, and no -exec on the STARTBINARGS. This is true for an unconfigured server.
	# Are there any situations where this might warn falsely? Might want to offer a disable option.
	if ! ( echo "$STARTBINARGS" | egrep -o " -exec" &> /dev/null ) && ! [[ -f "$GAMEDIR/cfg/autoexec.cfg" ]] && ! [[ -f "$GAMEDIR/cfg/server.cfg" ]] ; then
		echoerr ""
		echoerr "WARNING: No autoexec.cfg, server.cfg, or -exec in STARTBINARGS found."
		echoerr "  This probably means the server is not configured. It may fail to start correctly."
		echoerr ""
	fi
	# Continue if sane.
	#
	# NOTE: umask 002 (file:rw-rw-r-- dir:rwxrwxr-x) is needed so that replay files can be read by the web server.
	# NOTE: Global user umask set in /etc/login.defs
	#
	if [[ "$STARTBIN" == srcds_run ]] ; then
		# If the STARTBIN is srcds_run, we will only look for it in the BINDIR. PATH is not referenced.
		EVALTXT_START_CMD="tmux new-session -d -s $INSTALLID \"umask 002 ; cd $BINDIR ; ./$STARTBIN $STARTBINARGS\""
	else
		if [[ "$STARTBIN" == "$MYNAME" ]] ; then
			# If STARTBIN is wrench, we append "run" to make it run in wrench run mode.
			FQP_STARTBIN="$MYSELF run"
		else
			# If the STARTBIN is anything else, we look for it in PATH, and set it explicitly. FQP=Fully Qualified Path.
			# NOTE: tmux really likes to screw up PATH and env, so we explicitly set the path before tmux resets it's own PATH.
			FQP_STARTBIN=$(type -p $STARTBIN)
		fi
		# echo "DEBUG: MYSELF=$MYSELF"
		# echo "DEBUG: FQP_STARTBIN=$FQP_STARTBIN"
		# echo "DEBUG: PATH=$PATH"
		#
		# Additionally, we want to export a number of vars. wrench_run requires many of these, and alternatives could make use of them.
		# tmux does not accept any vars into new session environments, so we need to be clever in how we get these to the STARTBIN.
		# This command is complicated. Usage of env taking input from a double-nested command subsitution bash for loop with indirect parameter expansion
		# 	inside of a var which will be eval'ed later makes for one clusterfuck of a command. I should be drug out to the street and shot for this.
		EXPORT_VARS="IN_ARG APPDIR SQLITE SQLCMD SQLSHOWCMD SQLDBFILE STEAMCMD_BIN USER MYNAME RUNID NICECMD INSTALLID \
			INSTALLDIR GAMETYPE GAMENAME INSTTYPE STARTBIN GAMEARG BINDIR BINDIRSUBD USEMASTER LOCKFILE \
			PIDFILE IPADDR CLIENTPORT HOSTPORT TVPORT STEAMPORT ALLOWSTART BOOTSTART AUTOCLEANUP MAILTO \
			MAILER MAIL_SUBJ_PREFIX MAILNOTIFY HIPCHATNOTIFY RECOVER_CRASH_ENABLE RECOVER_WATCHDOG_ENABLE RECOVER_WATCHDOG_TEST_INTERVAL \
			RECOVER_WATCHDOG_POLL_MAX RECOVER_WATCHDOG_START_WAIT RECOVER_SLEEP TMUX_CAPTURE_OPTS"
		#
		# FIXME: We don't really need eval any more. We can show what tmux used as it's start command like so;
		#   tmux list-panes -t "$INSTALLID" -F '#{pane_start_command}'
		EVALTXT_START_CMD="tmux new-session -d -s $INSTALLID \"env $(echo $(for VAR in $EXPORT_VARS ; do echo "${VAR}='${!VAR}'" ; done) | tr '\n' ' ') $FQP_STARTBIN $STARTBINARGS\""
	fi
	#
	# echo ""
	# echo "DEBUG : The startup command shall be: "
	# echo "$EVALTXT_START_CMD"
	# echo ""
	# 
	# Execute it.
	eval $EVALTXT_START_CMD ; X_TMUXSTART=$?
	#
	# We set tmux remain-on-exit on here so that if the srcds_run/wrench_run process dies before
	#   srcds_linux starts the server, we can dump the window pane contents to a file, so that we
	#   review it later. Without this, tmux would close the session and we would have no idea what
	#   went wrong.
	#   Note that if tmux closes really fast, you might need to add a sleep 1 to the end of the new-session command.
	tmux set-window-option -t $INSTALLID:0 remain-on-exit on &> /dev/null
	#
	echo ""
	# Check the tmux exit code for errors.
	if [[ $X_TMUXSTART -ne 0 ]] ; then
		echoerr "ERROR: tmux failed to run or experienced an error."
		echoerr "  tmux exit code $X_TMUXSTART."
		echoerr "  Startup failed."
		echoerr ""
		return 1
	fi
	# Need to wait for the PIDFILE to be written, but tmux returns immediately.
	# We will wait until the PIDFILE is written. Sometimes this can take many seconds.
	if [[ -z "$(cat "$PIDFILE" 2> /dev/null)" ]] ; then # NOTE: We won't even hit this if the PIDFILE is written really fast (unlikely).
		echo -n "Starting $INSTALLID:"
		declare -i STARTWAITCOUNT=0
		until [[ -n "$(cat "$PIDFILE" 2> /dev/null)" ]] ; do
			# Check if the tmux pane died early. This is a sign that the STARTBIN or SRCDS_LINUX quit.
			if [[ "$(tmux list-panes -t "$INSTALLID" -F '#{pane_dead}' 2> /dev/null)" == 1 ]] ; then
				STARTUP_CAPTURE_PANE_FILE="$INSTALLDIR/crash_capture-pane_$(date +%Y%m%d%H%M%S)-$$.log"
				echoerr ""
				echoerr "ERROR: The STARTBIN or SRCDS_LINUX quit before the PIDFILE was written."
				echoerr "  We will capture the tmux session output to file. Review the file for details."
				echoerr "  Capture file: $STARTUP_CAPTURE_PANE_FILE"
				echoerr ""
				tmux capture-pane "$TMUX_CAPTURE_OPTS" -t "$INSTALLID":0.0 \; save-buffer "$STARTUP_CAPTURE_PANE_FILE"
				tmux kill-session -t "$INSTALLID"
				break
			fi
			# Check if the session has disappeared. This should not happen if "remain-on-exit on" has been set.
			if ! ( tmux has-session -t $INSTALLID 2> /dev/null ) ; then
				echoerr ""
				echoerr "ERROR: The tmux session has disappeared before the PIDFILE was written."
				echoerr ""
				break
			fi
			# Our timeout counter.
			STARTWAITCOUNT=$(( $STARTWAITCOUNT + 1))
			if [[ "$STARTWAITCOUNT" -gt 15 ]] ; then
				echoerr ""
				echoerr "ERROR: Done waiting. Startup may have failed. Check status."
				echoerr ""
				break
			fi
			sleep 1
			echo -n "."
		done ; unset STARTWAITCOUNT STARTUP_CAPTURE_PANE_FILE
		echo "Done"
	fi
	#
	# Since the server has started, we can allow tmux to kill sessions when they die again.
	tmux set-window-option -t $INSTALLID:0 remain-on-exit off &> /dev/null
	#
	# Now that the PIDFILE should be readable, get the PID
	f_getpid
	if [[ -n "$GAMESERVPID" ]] ; then
		echo "Server started at PID $GAMESERVPID."
	fi
	# Renice the process to make sure it runs as smooth as possible.
	# This requires pam_limits configuration via /etc/security/limits.conf
	# Note that wrench_run now does this too, so this should only be needed when STARTBIN is srcds_run or some other tool.
	# We will now test if this is configured properly, and use it if so.
	if [[ -n "$GAMESERVPID" ]] && (egrep "$USER.*nice" /etc/security/limits.conf &> /dev/null) ; then
		echo -n "Renicing srcds process: "
		# bash -c "renice -9 $GAMESERVPID 1> /dev/null" ; X_RENICE=$? # FIXME: WTF was I doing here with a bash -c?
		renice -n -9 "$GAMESERVPID" 1> /dev/null ; X_RENICE=$?
		if [[ ! "$X_RENICE" = 0 ]] ; then
			echoerr ""
			echoerr "Raising the priority of the game server process failed."
			echoerr "This might be due to pam_limits not being configured correctly."
			echoerr ""
		fi
		echo "Done"
	fi
	echo "Start completed."
	echo ""
}

f_stop() {
	# Stop a running installation.
	# 
	unset STOPFAIL
	local X_GETPID
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	# FIXME: For mail notifications, we really should not notify until later, after we know we CAN stop, and maybe after we know the exit code.
	f_mailnotify stop "Server stop request received."
	STOPFAIL=0
	f_getpid ; X_GETPID="$?"
	if [[ "$RUNSTATUS" == "running" ]] ; then
		echo ""
		# Give users warning that the server is going down, unless we are in a rush.
		if ! [[ "$STOPNOW" == yes ]] ; then
			STOPCOUNT=$STOPCOUNTDOWN
			echo -n "Giving players $STOPCOUNT seconds warning: "
			until [[ "$STOPCOUNT" -eq 0 ]] ; do
				echo -n "."
				# Send both say and cm_csay, since sm_csay requires sourcemod.
				if ! [[ -n "$MESSAGEDOWN" ]] ; then
					MESSAGEDOWN="Server is shutting down in $STOPCOUNT seconds!"
				fi

				tmux send-keys -t "$INSTALLID" \
					"sm_csay $MESSAGEDOWN" C-m
				tmux send-keys -t "$INSTALLID" \
					"say Server $MESSAGEDOWN" C-m
				STOPCOUNT=$(( $STOPCOUNT - 1))
				sleep 1
			done ; unset STOPCOUNT
			echo "Done"
		else
			# Stop more or less immediately.
			echo "Stopping now, without warning to players."
		fi
		# When countdown is done, send quit command
		tmux send-keys -t "$INSTALLID" "quit" C-m
		# Now verify that the process is actually gone via the PID.
		if [[ $(ps --no-headers -p "$GAMESERVPID" -o pid | wc -l) -gt 0 ]] ; then
			echo -n "Waiting for server to stop: "
			declare -i STOPWAITCOUNT=0
			while [[ $(ps --no-headers -p "$GAMESERVPID" -o pid | wc -l) -gt 0 ]] ; do
				STOPWAITCOUNT=$(( $STOPWAITCOUNT + 1))
				if [[ "$STOPWAITCOUNT" -gt "$STOPWAITFOR" ]] ; then
					echo ""
					echo "Giving up waiting after $STOPWAITFOR seconds. Stop may have failed."
					echo ""
					echo "Here's the process info:"
					ps uw -p "$GAMESERVPID"
					echo ""
					echo -n "Sending SIGQUIT to the process: "
					kill -SIGQUIT "$GAMESERVPID"
					echo "Done"
					STOPFAIL=1
					break
				fi
				sleep 1
				echo -n "."
			done ; unset STOPWAITCOUNT
			echo "Done"
		fi
		#
		# Kill the tmux session too. If "quit" causes a crash, it will just restart with a new PID.
		if ( tmux has-session -t "$INSTALLID" 2> /dev/null ) ; then
			echo -n "Waiting for tmux session to die: "
			declare -i TMUXDIEWAITCOUNT=0
			while ( tmux has-session -t "$INSTALLID" 2> /dev/null ) ; do
				TMUXDIEWAITCOUNT=$(( $TMUXDIEWAITCOUNT + 1))
				if [[ "$TMUXDIEWAITCOUNT" -gt 5 ]] ; then
					echo ""
					echo "Giving up waiting for tmux session to die."
					echo "  This may be caused by the srcds_linux process crashing upon \"quit\" being issued, which is common."
					echo -n "  I am going to kill the tmux session, which should kill everything: "
					tmux kill-session -t "$INSTALLID"
					echo "Done"
					STOPFAIL=1
					break
				fi
				sleep 1
				echo -n "."
			done ; unset TMUXDIEWAITCOUNT
			echo "Done"
		fi
		# Remove the PID file.
		rm -f "$PIDFILE" || { echoerr "ERROR: Failed to remove PIDFILE!" ; STOPFAIL=1 ; }
		if [[ "$STOPFAIL" == 0 ]] ; then
			echo "$INSTALLID was stopped successfully."
		else
			echoerr "$INSTALLID stop request encountered errors."
		fi
		echo ""
	elif [[ "$RUNSTATUS" == "stopped" ]] ; then
		echo ""
		echo "Installation already stopped. Nothing to do."
		echo ""
	elif [[ "$RUNSTATUS" == "crashed" ]] ; then
		echoerr ""
		echoerr "WARNING: The installation appears to be crashed."
		echoerr "  PIDFILE=\"$PIDFILE\", bogus PID is \"$GAMESERVPID\"."
		echoerr "  Since you requested a stop, I will remove the old PIDFILE automatically."
		echoerr ""
		if [[ -f "$PIDFILE" ]] ; then
			# If the PIDFILE exists, delete it.
			rm -f "$PIDFILE" || echoerr "ERROR: Unable to remove PIDFILE!"
		fi
		if ( tmux has-session -t "$INSTALLID" 2> /dev/null ) ; then
			# If the tmux session exists, kill it.
			tmux kill-session -t "$INSTALLID" &> /dev/null
		fi
	else
		echoerr ""
		echoerr "ERROR: Unable to get the installation's current operational status."
		echoerr "  This may be a temporary error (startup), or because the server has crashed."
		echoerr "  Since you requested a stop, I will attempt to perform a forceful shutdown and cleanup."
		echoerr ""
		if [[ -f "$PIDFILE" ]] ; then
			# If the PIDFILE exists, delete it.
			rm -f "$PIDFILE" || echoerr "ERROR: Unable to remove PIDFILE!"
		fi
		if ( tmux has-session -t "$INSTALLID" 2> /dev/null ) ; then
			# If the tmux session exists, kill it.
			tmux kill-session -t "$INSTALLID" &> /dev/null
		fi
		echoerr "Cleanup completed."
		echoerr ""
	fi
}

f_stopall() {
	# Stop ALL running srcds installations.
	# 
	f_listrunning
	echo ""
	if [[ -z "$LIST_RUNNING" ]] ; then
		echo "No running installations found. Nothing to stop."
		echo ""
		return 0
	else
		echo "Stopping all running installations: $(echo $LIST_RUNNING | tr '\n' ' ')"
		echo ""
		for EACH in $LIST_RUNNING; do
			( IN_INSTALLID="$EACH"
			echo "Stopping $EACH"
			f_stop
			echo "--"
			echo "" )
		done ; unset EACH IN_INSTALLID
		echo "All running installations stopped."
		echo ""
	fi
}

f_bootstart() {
	# Start all bootstartable srcds installations.
	#
	f_listbootstartable
	echo ""
	echo "Starting all bootstartable installations: $(echo $LIST_BOOTSTARTABLE | tr '\n' ' ')"
	for EACH in $LIST_BOOTSTARTABLE ; do
		( IN_INSTALLID="$EACH"
		f_loaddbinst
		if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then continue ; fi
		# If the installation is already running, we must not try to start it.
		f_getpid ; X_GETPID="$?"
		if [[ "$RUNSTATUS" == "stopped" ]] ; then
			f_start
			echo "--"
			continue
		elif [[ "$RUNSTATUS" == "running" ]] ; then
			echo ""
			echo "Installation $INSTALLID is already running."
			echo ""
			echo "--"
			continue
		elif [[ "$RUNSTATUS" == "crashed" ]] ; then
			echoerr ""
			echoerr "WARNING: Installation $INSTALLID appears to be crashed."
			echoerr "  If the host shut down before the running installations were stopped, it may have caused this situation."
			echoerr "  Recommended course of action is to stop the installation to force a cleanup."
			echoerr "  Skipping $INSTALLID."
			echoerr ""
			echoerr "--"
			continue
		else
			echoerr ""
			echoerr "WARNING: $INSTALLID is currently in error status. Unable to start."
			echoerr "  Skipping $INSTALLID."
			echoerr ""
			echoerr "--"
			continue
		fi )
	done ; unset EACH IN_INSTALLID
	echo ""
	echo "Done"
	echo ""
}

f_status() {
	# Display the status of a particular installation. Intended mostly to display info about active/running installations.
	# 
	local PROCINFO_ARGS PROCINFO_PCPU PROCINFO_PPRIO PROCINFO_PSR PROCINFO_EUSER PROCINFO_RSS PROCINFO_VSZ PROCINFO_LSTART PROCINFO_ETIME PROCINFO_CPUTIME
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	f_getpid ; X_GETPID="$?"
	if [[ "$RUNSTATUS" == "running" ]] ; then
		echo ""
		echo "Showing status for $INSTALLID"
		echo ""
		echo "tmux session: $(tmux list-sessions | egrep "^ *$INSTALLID: ")"
		echo ""
		echo "Game server PID: $GAMESERVPID"
		echo ""
		echo "Configured IP:Hostport: $IPADDR:$HOSTPORT"
		echo ""
		PROCINFO_ARGS=$(ps --no-headers -p $GAMESERVPID -o args)
		echo "Process command arguments (from ps): "
		echo "$PROCINFO_ARGS"
		echo ""
		echo "Various ps stats:"
		#
		PROCINFO_PCPU=$(ps --no-headers -p $GAMESERVPID -o pcpu)
		PROCINFO_PPRIO=$(ps --no-headers -p $GAMESERVPID -o pri | sed -e "s/ \{1,\}//g")
		PROCINFO_PSR=$(ps --no-headers -p $GAMESERVPID -o psr | sed -e "s/ \{1,\}//g")
		PROCINFO_EUSER=$(ps --no-headers -p $GAMESERVPID -o euser)
		PROCINFO_RSS=$(ps --no-headers -p $GAMESERVPID -o rss)
		PROCINFO_VSZ=$(ps --no-headers -p $GAMESERVPID -o vsz)
		PROCINFO_LSTART=$(ps --no-headers -p $GAMESERVPID -o lstart)
		PROCINFO_ETIME=$(ps --no-headers -p $GAMESERVPID -o etime | sed -e "s/ \{1,\}//g")
		PROCINFO_CPUTIME=$(ps --no-headers -p $GAMESERVPID -o cputime)
		#
		( echo "  CPU usage percent per-core:|$PROCINFO_PCPU%"
		echo "  Process priority (normal=19, higher=better):|$PROCINFO_PPRIO"
		echo "  Running on processor core:|$PROCINFO_PSR"
		echo "  Running as effective user:|$PROCINFO_EUSER"
		echo "  RSS/Real memory usage:|$PROCINFO_RSS KB"
		echo "  VSZ/Virtual memory usage:|$PROCINFO_VSZ KB"
		echo "  Process started at:|$PROCINFO_LSTART"
		echo "  Process started elapsed-time ago:|$PROCINFO_ETIME"
		echo "  Process CPU in-use time:|$PROCINFO_CPUTIME"
		) | column -t -s "|"
		echo ""
		echo "lsof says the following network sockets are in use by PID $GAMESERVPID:"
		lsof -i -n -a -p $GAMESERVPID | column -t
		echo ""
		echo "qstat player list for $INSTALLID:"
		f_qstat -P -a2s "$IPADDR":"$HOSTPORT"
		echo ""
		echo "Done"
	elif [[ "$RUNSTATUS" == "stopped" ]] ; then
		echo ""
		echo "$IN_INSTALLID: Installation not running."
		echo ""
	elif [[ "$RUNSTATUS" == "crashed" ]] ; then
		echoerr ""
		echoerr "WARNING: The installation appears to be crashed."
		echoerr "  Recommended course of action is to stop the installation to force a cleanup."
		echoerr ""
	else
		echoerr ""
		echoerr "WARNING: Unable to determine the status of the installation."
		echoerr "  This might be a temporary problem. Try again?"
		echoerr ""
	fi
}

f_listinstalls() {
	# List all valid installations. This is determined by an entry in the DB inst table, then we look for a directory in $APPDIR.
	#
	local LIST_INSTALLS
	#
	echo ""
	LIST_INSTALLS=$($SQLCMD "select INSTALLID from inst;")
	if [[ -z "$LIST_INSTALLS" ]] ; then
		echo "No installations were found."
		echo ""
		return 0
	else
		echo "The following installations were found: "
		echo ""
		# Write out in column format.
		( echo "Install ID|Install Type|Run Status" ; echo "--|--|--"
		for EACH_LISTINSTALL in $LIST_INSTALLS ; do
			IN_INSTALLID="$EACH_LISTINSTALL"
			f_loaddbinst
			if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then continue ; fi
			f_getpid ; X_GETPID="$?"
			echo "$INSTALLID|$INSTTYPE|$RUNSTATUS"
		done ; unset EACH_LISTINSTALL IN_INSTALLID
		) | column -t -s "|"
		echo ""
	fi
}

f_listplayers() {
	# Show a list of all running srcds installations with their qstat player listings.
	#
	# qstat is required.
	if [[ "$QSTAT_MISSING" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: qstat command not found. Quitting."
		echoerr ""
		exit 1
	fi
	f_listrunning
	#
	# Print notice if no running servers found
	if [[ -z "$LIST_RUNNING" ]] ; then
		echo ""
		echo "No running servers found."
		echo ""
		return 0
	fi
	#
	echo ""
	echo "Listing all players on all active srcds servers: "
	echo ""
	#
	echo "Local time is: $(date)"
	echo ""
	# Write each fifo so that we can read it later
	# We use fifos here so that we can do the polling in parallel, making this process much faster.
	LISTINGPLAYERS=1
	# FIXME: Why not do a standard inst load here?
	for EACH in $LIST_RUNNING ; do
		( while IFS='|' read IPADDR HOSTPORT ; do
			DB_IPADDR=$IPADDR
			DB_HOSTPORT=$HOSTPORT
		done < <($SQLCMD "select IPADDR,HOSTPORT from inst where INSTALLID='$EACH';")
		# Normalize database parameters.
			IPADDR=$DB_IPADDR
			HOSTPORT=$DB_HOSTPORT
		# echo "working on: $EACH $IPADDR:$HOSTPORT"
		QSTATOUT=/tmp/qstat-out-$EACH-$RUNID
		mkfifo $QSTATOUT
		echo "$(f_qstat -P -a2s $IPADDR:$HOSTPORT)" 1> $QSTATOUT 2> /dev/null ) &
		unset QSTATOUT IPADDR DB_IPADDR HOSTPORT DB_HOSTPORT
	done ; unset EACH
	# sleep to make the output look a little more consistent, since qstat sleeps 1 anyway.
	sleep 2
	#
	# Read out the results
	for EACH in $LIST_RUNNING ; do
		( QSTATOUT=/tmp/qstat-out-$EACH-$RUNID
		echo "qstat player list for $EACH:"
		cat "$QSTATOUT"
		echo ""
		rm -f "$QSTATOUT" ) ; unset QSTATOUT
	done ; unset EACH
	LISTINGPLAYERS=0
	echo ""
}

f_lockdownmaster() {
	# Lock down the filesystem permissions on a master installation to prevent accidental changes.
	# This also sets sane permissions, such as all files not being ugo+x. This replaces fixperms.
	#
	unset LOCKMASTER_FAIL
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	echo ""
	# The installation specified must be a master type install, otherwise quit.
	if [[ ! "$INSTTYPE" == master ]] ; then
		echoerr "ERROR: This command can only be used against a \"master\" type installation."
		echoerr "  $INSTALLID is a \"$INSTTYPE\" type installation."
		echoerr ""
		return 1
	fi
	echo -n "Locking down the master installation: "
	$NICECMD find "$INSTALLDIR" -type f -exec chmod ugo-x '{}' + # Remove all needless file execute perms.
	for EACH in $($NICECMD find "$BINDIR" -mindepth 1 -maxdepth 1 -type f -name "srcds_*" | egrep "^$BINDIR/srcds_[amd$|i386$|i486$|i586$|i686$|run$|linux$|osx$]") ; do
		# echoerr "DEBUG: Adding +x bit on $EACH"
		chmod ug+x "$EACH" || LOCKMASTER_FAIL=1 # Re-add execute perms for only those files which should have them.
	done ; unset EACH
	$NICECMD find "$INSTALLDIR" -type f -exec chmod ugo+r '{}' + || LOCKMASTER_FAIL=1
	$NICECMD find "$INSTALLDIR" -type d -exec chmod ugo+rx '{}' + || LOCKMASTER_FAIL=1
	$NICECMD find "$INSTALLDIR" -type f -exec chmod ugo-w '{}' + || LOCKMASTER_FAIL=1
	$NICECMD find "$INSTALLDIR" -type d -exec chmod ugo-w '{}' + || LOCKMASTER_FAIL=1
	if [[ "$LOCKMASTER_FAIL" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: Locking master installation \"$INSTALLDIR\" failed."
		echoerr ""
		return 1
	fi
	echo "Done"
	echo ""
}

f_unlockmaster() {
	# Unlock the master installation for writing. The only time this should be needed is for updating or intentional modification of the master.
	#
	unset UNLOCKMASTER_FAIL
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	echo ""
	# The installation specified must be a master type install, otherwise quit.
	if [[ ! "$INSTTYPE" == master ]] ; then
		echoerr "ERROR: unlock-master can only be used against a \"master\" type installation."
		echoerr "  $INSTALLID is a \"$INSTTYPE\" type installation."
		echoerr ""
		return 1
	fi
	echo -n "Unlocking the master installation: "
	$NICECMD find "$INSTALLDIR" -type d -exec chmod ug+w '{}' + || UNLOCKMASTER_FAIL=1
	$NICECMD find "$INSTALLDIR" -type f -exec chmod ug+w '{}' + || UNLOCKMASTER_FAIL=1
	if [[ "$UNLOCKMASTER_FAIL" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: Unlocking master installation \"$INSTALLDIR\" failed."
		echoerr ""
		return 1
	fi
	echo "Done"
	echo ""
}

f_getlocalver() {
	# Get the local application version.
	#
	unset LOCAL_VER
	#
	# If we don't have a valid INSTVER_METHOD, then we can't do anything.
	if [[ "$INSTVER_METHOD" == steaminf ]] ; then
		# We must have a valid Steam.inf file to work with.
		if [[ -z "$STEAMINF_FILE" ]] ; then
			echoerr "ERROR: Call to get the local application version, but STEAMINF_FILE is invalid."
			return 1
		fi
		LOCAL_VER=$(egrep "^PatchVersion=" "$STEAMINF_FILE" | cut -f 2 -d "=" | tr -c -d [:digit:])
	elif [[ "$INSTVER_METHOD" == db ]] ; then
		# Get the local version from the srcinfo table INSTVER column.
		# We assume the currently installed version is the previous required_version from the last update.
		LOCAL_VER=$INSTVER
	else
		echoerr ""
		echoerr "ERROR: INSTVER_METHOD not valid. INSTVER_METHOD=\"$INSTVER_METHOD\""
		echoerr "  Unable to get the local version."
		echoerr ""
		return 1
	fi
}

f_getup2datereqver() {
	# Get the remote Required Version from Valve's UpToDate WebAPI.
	#
	unset UPTODATECHECK_URL REMOTE_VER
	#
	# Without the CLIENT_APPID, we can do nothing.
	if [[ -z "$CLIENT_APPID" ]] ; then
		echoerr "ERROR: Call to get the remote Required Version, but CLIENT_APPID is invalid."
		return 1
	fi
	UPTODATECHECK_URL="http://api.steampowered.com/ISteamApps/UpToDateCheck/v1?appid=${CLIENT_APPID}&version=0&format=xml"
	# wget 3 tries with 3 second timeouts should be okay for most users. Default is 20 tries with a 900 second timeout, which is unreasonable.
	REMOTE_VER=$(wget --timeout=3 --tries=3 -O - "$UPTODATECHECK_URL" 2> /dev/null | xmlstarlet sel -t -v "response/required_version" 2> /dev/null)
}

f_update_steamcmd() {
	# Update with SteamCMD/SteamPipe
	# Note that we don't do any lock checking here. f_update does that.
	#
	local STEAMCMD_UPDATE_COUNTER UPDATEARG EVALTXT_STEAMCMD_UPDATE_CMD X_UPDATE_STEAMCMD
	#
	echo ""
	#
	# If SteamCMD is not found, there is nothing we can do.
	if [[ ! -x "$STEAMCMD_BIN" ]] ; then
		echoerr "ERROR: Unable to find the SteamCMD installation."
		echoerr ""
		return 2
	fi
	if [[ -z "$SERVER_APPID" ]] ; then
		echoerr "ERROR: Request to update with SteamCMD, but we have no APPID to work with."
		echoerr ""
		return 2
	fi
	if [[ "$VERIFYUPDATE" == "1" ]] ; then
		UPDATEARG="+app_update $SERVER_APPID validate"
		# echoerr "DEUBG: Updating with SteamCMD validate"
	else
		UPDATEARG="+app_update $SERVER_APPID"
		# echoerr "DEBUG: Updating with SteamCMD"
	fi
	# cd to the APPDIR, so steamcmd doesn't litter crap wherever $PWD happens to be.
	cd $APPDIR
	#
	EVALTXT_STEAMCMD_UPDATE_CMD="$NICECMD $STEAMCMD_BIN +@ShutdownOnFailedCommand 1 +login \"anonymous\" +force_install_dir $INSTALLDIR/ $UPDATEARG +exit"
	echo "SteamCMD running command: "
	echo "  $EVALTXT_STEAMCMD_UPDATE_CMD"
	echo ""
	#
	declare -i STEAMCMD_UPDATE_COUNTER="0"
	while true ; do
		eval $EVALTXT_STEAMCMD_UPDATE_CMD ; X_UPDATE_STEAMCMD=$?
		STEAMCMD_UPDATE_COUNTER=$(( $STEAMCMD_UPDATE_COUNTER + 1)) # Increment the counter
		# echo "" # SteamCMD seems to add a blank line after exit anyway.
		echo "SteamCMD exit code: $X_UPDATE_STEAMCMD"
		if [[ "$X_UPDATE_STEAMCMD" = 0 ]] ; then
			echo "SteamCMD completed successfully."
			echo ""
			break
		else
			if [[ "$STEAMCMD_UPDATE_COUNTER" -lt "$UPDATETRIES" ]] ; then
				echo "SteamCMD attempt $STEAMCMD_UPDATE_COUNTER failed, will try again."
				echo ""
				sleep 0
				continue
			fi
			if [[ "$STEAMCMD_UPDATE_COUNTER" -eq "$UPDATETRIES" ]] ; then
				echoerr "SteamCMD failed $STEAMCMD_UPDATE_COUNTER times. Giving up."
				echoerr ""
				return 1
			fi
		fi
	done ; unset STEAMCMD_UPDATE_COUNTER X_UPDATE_STEAMCMD
}

f_update() {
	# Update a srcds installation.
	#
	unset UPDATER_FAIL UPDATING
	local X_UPDATER X_UPDATE_SETLOCK X_UPDATE_RMLOCK X_LOCKMASTER UPDATE_POSTCHECK_COUNTER POSTCHECK_LOCAL_VER POSTCHECK_REMOTE_VER
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	#
	# If ALLOWUPDATE is not 1, do not allow.
	if [[ ! "$ALLOWUPDATE" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: ALLOWUPDATE disabled. Updating this installation is not allowed."
		echoerr ""
		return 1
	fi
	# We must only update valid installation types.
	case "$INSTTYPE" in
		'linked') # Never update a linked install. That's what relinking is for.
			echoerr ""
			echoerr "ERROR: $INSTALLID is a $INSTTYPE type installation."
			echoerr "  This type of installation should never be updated directly. Update the master instead."
			echoerr "  If you need to relink the installation, use the \"relink\" argument."
			echoerr ""
			return 1
		;;
		'master') # Okay to proceed.
			true
			# echo "NOTE: $INSTALLID is a $INSTTYPE installation."
		;;
		*)
			echoerr ""
			echoerr "ERROR: $INSTALLID installation type invalid. Unable to update."
			echoerr ""
			return 1
		;;
	esac
	# Lockfile pre-check and set
	f_lockcheck
	if [[ "$LOCKFAIL" == 1 ]] ; then return 1 ; fi
	f_unlockmaster ; X_UNLOCKMASTER="$?" # Unlock the master for writing.
	if [[ ! "$X_UNLOCKMASTER" == 0 ]] ; then return 1 ; fi
	#
	UPDATING=1
	echo "$MYPID" >> $LOCKFILE ; X_UPDATE_SETLOCK="$?"
	if [[ ! "$X_UPDATE_SETLOCK" == 0 ]] ; then
		echoerr ""
		echoerr "ERROR: Unable to write lockfile for update!"
		echoerr ""
		UPDATING=0
		return 1
	fi
	#
	while true ; do
		# Choose and use the update tool on the target installation.
		# NOTE: Previously HLDSUpdateTool was an option, but now only SteamCMD is supported. There may be related cruft. 
		case "$UPDATER" in
			'SteamCMD')
				echo "Updater using SteamCMD."
				f_update_steamcmd ; X_UPDATER="$?"
			;;
			*)
				echoerr ""
				echoerr "ERROR: Unknown UPDATER type. Unable to proceed."
				echoerr ""
				UPDATING=0
				return 1
		esac
		#
		# Now that we ran the updater, we need to verify that it worked, and if it didn't try again or fail out.
		# Remember that our updater itself may retry internally, so this may be redundant.
		#   Sometimes the Steam Cloud content depots are out of date when updates get released, or Steam services are down/broken. 
		#   Often, waiting a little while fixes the issue.
		#
		UPDATE_POSTCHECK_COUNTER=$(( $UPDATE_POSTCHECK_COUNTER + 1)) # Increment the counter
		#
		# If we were called via an autoupdate, we sleep between attempts. Otherwise we try again immediately.
		# FIXME: Should really do this as cron vs interactive, but need a test method.
		if [[ ! "$IN_ARG" == "autoupdate" ]] ; then
			AUTOUPDATE_SLEEP2="0"
		fi
		#
		if [[ "$X_UPDATER" == 2 ]] ; then
			# X_UPDATER=2 is a permanant error. Retrying won't help. Give up immediately.
			UPDATER_FAIL=1
			break
		elif [[ "$X_UPDATER" == 1 ]] ; then
			# X_UPDATER=1 is a soft error. Trying again might result in success.
			if [[ "$UPDATE_POSTCHECK_COUNTER" -lt "$AUTOUPDATE_POSTCHECK_RETRIES" ]] ; then
				echo "Updater try $UPDATE_POSTCHECK_COUNTER failed. Will try again in $AUTOUPDATE_SLEEP2 seconds."
				echo ""
				sleep "$AUTOUPDATE_SLEEP2"
				continue
			else
				UPDATER_FAIL=1
				echoerr "ERROR: Updater tried $UPDATE_POSTCHECK_COUNTER times already. Will not try again."
				echoerr ""
				break
			fi
		elif [[ "$X_UPDATER" == 0 ]] ; then
			# We can only do a post-check if we compare the remote version to the local version from the steam.inf file.
			if [[ "$INSTVER_METHOD" == steaminf ]] ; then
				# We compare the remote and local versions. If they are out of sync, that is a problem.
				f_getlocalver ; POSTCHECK_LOCAL_VER="$LOCAL_VER"
				f_getup2datereqver ; POSTCHECK_REMOTE_VER="$REMOTE_VER"
				if [[ "$POSTCHECK_LOCAL_VER" == "$POSTCHECK_REMOTE_VER" ]]; then
					# Record the INSTVER as $REMOTE_VER
					$SQLCMD "update inst set INSTVER='$REMOTE_VER' where INSTALLID='$INSTALLID';"
					UPDATER_FAIL=0
					echo "Post-update version check result: Success"
					echo ""
					break
				else
					if [[ "$UPDATE_POSTCHECK_COUNTER" -lt "$AUTOUPDATE_POSTCHECK_RETRIES" ]] ; then
						echo "Post-updater version check failed on try $UPDATE_POSTCHECK_COUNTER. Will try again in $AUTOUPDATE_SLEEP2 seconds."
						echo ""
						sleep "$AUTOUPDATE_SLEEP2"
						continue
					else
						UPDATER_FAIL=1
						echoerr "ERROR: Post-updater version check failed on try $UPDATE_POSTCHECK_COUNTER. Will not try again."
						echoerr "POSTCHECK_LOCAL_VER=$POSTCHECK_LOCAL_VER, POSTCHECK_REMOTE_VER=$POSTCHECK_REMOTE_VER"
						echoerr ""
						break
					fi
				fi
			else
				# Since we have no other way to compare the local version to what Valve's UpToDateURL says, we have to assume success.
				# FIXME 20150604: I don't like this. We should get remote version sooner.
				UPDATER_FAIL=0
				# Record the INSTVER as $REMOTE_VER
				f_getup2datereqver
				$SQLCMD "update inst set INSTVER='$REMOTE_VER' where INSTALLID='$INSTALLID';"
				break
			fi
		fi
		#
	done ; unset UPDATE_POSTCHECK_COUNTER
	#
	UPDATING=0
	# Remove lockfile
	rm -f $LOCKFILE ; X_UPDATE_RMLOCK="$?"
	if [[ ! "$X_UPDATE_RMLOCK" == 0 ]] ; then
		echoerr "ERROR: Unable to remove lockfile post-update!"
		echoerr ""
		return 1
	fi
	#
	if [[ "$UPDATER_FAIL" == 1 ]] ; then
		echoerr "The updater failed. Please see previous errors and warnings for more information."
		echoerr ""
		f_lockdownmaster ; X_LOCKMASTER="$?" # Lock down the master from writing when done, even if we did fail.
		return 1
	else
		f_lockdownmaster ; X_LOCKMASTER="$?" # Lock down the master from writing when done.
		# Even if there are problems, continue # if [[ ! "$X_LOCKMASTER" == 0 ]] ; then return 1 ; fi
	fi
	echo "Update on \"$INSTALLID\" completed."
	echo ""
}

f_autoupdate_warnallactive() {
	# Warn an active running srcds instances which could be impacted by resource contention.
	# FIXME: Should probably merge this with f_autoupdate.
	# 
	local WARNMESG_TEXT
	#
	f_listrunning
	#
	# If there are active/running srcds instances, then warn them.
	if [[ -z "$LIST_RUNNING" ]] ; then
		echo "No active srcds instances to warn of impending updates."
		echo ""
	else
		echo "Sending warnings of impending updates to all active srcds instances: "
		WARNMESG_TEXT="ATTENTION: Server maintenance in progress. This may harm game performance. Please be patient."
		for WARNTARGET in $LIST_RUNNING ; do
			# Repeat ourselves a few times.
			# Group this in a compound command with ( ) and run in the background
			( tmux send-keys -t $WARNTARGET "say $WARNMESG_TEXT" C-m
			tmux send-keys -t $WARNTARGET "sm_csay $WARNMESG_TEXT" C-m
			sleep 2
			tmux send-keys -t $WARNTARGET "say $WARNMESG_TEXT" C-m
			tmux send-keys -t $WARNTARGET "sm_csay $WARNMESG_TEXT" C-m
			sleep 2
			tmux send-keys -t $WARNTARGET "say $WARNMESG_TEXT" C-m
			tmux send-keys -t $WARNTARGET "sm_csay $WARNMESG_TEXT" C-m
			sleep 2
			tmux send-keys -t $WARNTARGET "say $WARNMESG_TEXT" C-m
			tmux send-keys -t $WARNTARGET "sm_csay $WARNMESG_TEXT" C-m
			echo "  Sent in-game warnings to $WARNTARGET" ) &
		done ; unset WARNTARGET
		wait # Wait for the backgrounded warnings to finish. This is a simple way of doing it in parallel.
		echo "Done warning active installations."
	fi
}

f_autoupdate_stopactivechildren() {
	# Shut down active children prior to updating the srcds master.
	# FIXME: Should probably merge this with f_autoupdate.
	#
	local SHUTDOWN_TEXT
	#
	if [[ -z "$ACTIVECHILD_LIST" ]] ; then
		echo "No active child srcds instances to shut down."
		echo ""
	else
		echo "Stopping all active children: "
		SHUTDOWN_TEXT="ATTENTION: A server update has been released! The server will now restart."
		for STOPTARGET in $ACTIVECHILD_LIST ; do
			# Warn all active children of a particular master installation GAMETYPE.
			( tmux send-keys -t $STOPTARGET "say $SHUTDOWN_TEXT" C-m
			tmux send-keys -t $STOPTARGET "sm_csay $SHUTDOWN_TEXT" C-m
			sleep 2
			tmux send-keys -t $STOPTARGET "say $SHUTDOWN_TEXT" C-m
			tmux send-keys -t $STOPTARGET "sm_csay $SHUTDOWN_TEXT" C-m
			sleep 2
			tmux send-keys -t $STOPTARGET "say $SHUTDOWN_TEXT" C-m
			tmux send-keys -t $STOPTARGET "sm_csay $SHUTDOWN_TEXT" C-m
			sleep 2
			IN_INSTALLID="$STOPTARGET" ; f_stop 1> /dev/null
			echo "  $STOPTARGET stopped" ) &
		done ; unset STOPTARGET
		wait # Wait for the backgrounded warnings to finish. This is a simple way of doing it in parallel.
		echo "Done stopping active installations."
		echo ""
	fi
}

f_autoupdate() {
	# Automatically update all installations.
	# Masters get updates via SteamCMD/HLDSUpdateTool, and linked installs get stopped/relinked/started.
	#
	unset AUTOUPDATING
	local AUTOUPDATE_MAILTO LIST_MASTERS MASTERUPDATE_LIST AUTOUPDATING_SEEN_UPDATES AUTOUPDATE_SLEEP1_COUNTDOWN
	local CURRENTMASTER IN_INSTALLID GAMETYPE ALLCHILD_LIST ACTIVECHILD_LIST INACTIVECHILD_LIST X_UPDATE_MAIN
	local AUTOUPDATE_MAIL_SUBJ AUTOUPDATE_MAIL_MESSAGE
	# Set a global MAILTO address.
	AUTOUPDATE_MAILTO=$WRENCH_MAILTO
	#
	# Update lock system for autoupdates.
	if [[ -f "$AUTOUPDATE_LOCKFILE" ]] ; then
		echo ""
		echo "$MYNAME is already running at PID \"$(cat $AUTOUPDATE_LOCKFILE)\"."
		echo "This is normal if updates are already in progress."
		echo "PID/Lockfile: $AUTOUPDATE_LOCKFILE"
		echo ""
		return 5
	fi
	#
	# Get a list of all MASTER installations.
	LIST_MASTERS=$($SQLCMD "select INSTALLID from inst where INSTTYPE='master';")
	#
	if [[ -z "$LIST_MASTERS" ]] ; then
		echo ""
		echo "No master srcds installations found to update."
		echo ""
		return 0
	fi
	AUTOUPDATING=1
	echo "$MYPID" > "$AUTOUPDATE_LOCKFILE" # Set the autoupdate lockfile.
	#
	# This is a dirty hack to tee our stdout and stderr to a logfile.
	# WARNING: This combines stderr into stdout and can not be undone.
	if [[ ! -d "$AUTOUPDATE_LOGDIR" ]] ; then
		mkdir "$AUTOUPDATE_LOGDIR" || { echoerr "ERROR: mkdir \$AUTOUPDATE_LOGDIR failed!" ; }
	fi
	# FIXME: cleanup trap not triggering on ctrl+c. I suspect the log redirect via "exec > >" below (confirmed).
	# https://stackoverflow.com/questions/24111981/how-can-i-achieve-bash-exit-trap-when-exec-ing-another-binary
	# exec > >(tee $AUTOUPDATE_LOGFILE) 2>&1
	#
	echo ""
	echo "Searching for updates to srcds MASTER installations: "
	echo "Start time is: $(date), RUNID=$RUNID"
	echo ""
	#
	# Iterate through the list of MASTER installs, get the local and remote versions, and add to the update list if needed
	for EACH in $LIST_MASTERS ; do
		echo "--"
		echo "Checking: $EACH"
		IN_INSTALLID="$EACH" ; f_loaddbinst # Load the DB info for the installation.
		if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then continue ; fi
		echo "$EACH: Local steam.inf filepath: $STEAMINF_FILE"
		if [[ ! -r "$STEAMINF_FILE" ]] ; then
			echoerr "ERROR: Unable to read STEAMINF file. Skipping MASTER installation $EACH"
			echoerr ""
			continue
		fi
		f_getlocalver
		if [[ -z "$LOCAL_VER" ]] ; then
			echoerr "ERROR: Unable to obtain the local version. Skipping $EACH."
			echoerr ""
			continue
		fi
		echo "$EACH: Local version: $LOCAL_VER from $INSTVER_METHOD"
		f_getup2datereqver
		echo "$EACH: Remote UpToDateCheck URL is: $UPTODATECHECK_URL"
		if [[ -z "$REMOTE_VER" ]] ; then
			echoerr "ERROR: Unable to obtain the remote version. Skipping $EACH."
			echoerr ""
			continue
		fi
		echo "$EACH: Remote version: $REMOTE_VER"
		# Test that we are allowed to update this installation.
		if [[ ! "$ALLOWUPDATE" == 1 ]] ; then
			echo "NOTE: Updating this installation is not allowed. Skipping $EACH."
			echo ""
			continue
		fi
		if [[ "$LOCAL_VER" == "$REMOTE_VER" ]]; then
			echo "$EACH: Result: Up to date."
		else
			echo "$EACH: Result: Installation out of date. Added to updatelist."
			# Append to the update list.
			if [[ -z $MASTERUPDATE_LIST ]] ; then
				MASTERUPDATE_LIST="$EACH"
			else
				MASTERUPDATE_LIST="$MASTERUPDATE_LIST $EACH"
			fi
		fi
	done ; unset EACH IN_INSTALLID
	echo "--"
	echo ""
	if [[ -z "$MASTERUPDATE_LIST" ]] ; then
		echo "No MASTER installation requires updating at this time."
	else
		# Since we have real work to do, we will record as such, for later use.
		AUTOUPDATING_SEEN_UPDATES=1
		#
		# Send an update start notification. The update process itself can take awhile.
		$MAILER -s "$MAIL_SUBJ_PREFIX autoupdate $RUNID started" $AUTOUPDATE_MAILTO <<-ENDMESSAGE
	
			Date: $(date)
			Master Update List: $MASTERUPDATE_LIST
	
		ENDMESSAGE
		#
		# If any master installations need to be updated, this could affect in-game performance of all active srcds instances.
		# We need a list of ALL active srcds instances, regardless of type, for in-game maintenance warning notification messages.
		#
		f_autoupdate_warnallactive
		#
		echo ""
		echo "The following MASTER installations require updating: "
		for EACH in $MASTERUPDATE_LIST ; do echo "  $EACH" ; done ; unset EACH
		echo ""
		#
		# Sleep for awhile. This is because it I found it common that the UpToDateCheck URL would report an update, but
		# the repository had not actually yet been updated. This would result in HLDSUpdateTool/SteamCMD being run, exit 0
		# without having downloaded any files, and then the auto-update script runs again because the update was not correctly
		# downloaded the first time. This should help prevent such failures.
		# Take into consideration the warning sleeps above. In total, we should wait 60-120 seconds?
		echo -n "Sleeping for $AUTOUPDATE_SLEEP1 seconds:"
		# sleep "$AUTOUPDATE_SLEEP1"
		declare -i AUTOUPDATE_SLEEP1_COUNTDOWN="$AUTOUPDATE_SLEEP1"
		while [[ "$AUTOUPDATE_SLEEP1_COUNTDOWN" -gt 0 ]] ; do
			echo -n "."
			AUTOUPDATE_SLEEP1_COUNTDOWN=$(( $AUTOUPDATE_SLEEP1_COUNTDOWN - 1))
			sleep 1
		done ; unset AUTOUPDATE_SLEEP1_COUNTDOWN
		echo "Done"
		echo ""
		#
		# Now that we have warned all active instances, let's carry on with processing each master which needs an update.
		#
		for CURRENTMASTER in $MASTERUPDATE_LIST ; do
			# For each master, we need to relink it's children, restart each, etc.
			echo "Processing master $CURRENTMASTER: "
			echo ""
			IN_INSTALLID="$CURRENTMASTER" ; f_loaddbinst # Load the DB info for the installation.
			if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then continue ; fi
			# ALLCHILD_LIST = All linked children for each master
			ALLCHILD_LIST=$($SQLCMD "select INSTALLID from inst where GAMETYPE='$GAMETYPE' and INSTTYPE='linked';")
			for CHILD in $ALLCHILD_LIST ; do
				# For each child installation, we need to know if it is or is not currently active.
				IN_INSTALLID="$CHILD" ; f_loaddbinst ; f_getpid # Load the DB info for the installation.
				if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then continue ; fi
				if [[ "$RUNSTATUS" == "running" ]] ; then
					# ACTIVECHILD_LIST = All running/active linked children for each master.
					if [[ -z "$ACTIVECHILD_LIST" ]] ; then
						ACTIVECHILD_LIST="$CHILD"
					else
						ACTIVECHILD_LIST="$ACTIVECHILD_LIST $CHILD"
					fi
				else
					# INACTIVECHILD_LIST = All non-running/inactive linked children for each master.
					# If RUNSTATUS is "crashed" or "error", the installation will be relinked, but it will not get restarted.
					if [[ -z "$INACTIVECHILD_LIST" ]] ; then
						INACTIVECHILD_LIST="$CHILD"
					else
						INACTIVECHILD_LIST="$INACTIVECHILD_LIST $CHILD"
					fi
				fi
			done ; unset CHILD IN_INSTALLID
			if [[ -z "$ACTIVECHILD_LIST" ]] ; then
				echo "$CURRENTMASTER has no active linked children."
				echo ""
			else
				echo "Active linked children of $CURRENTMASTER: "
				for EACH in $ACTIVECHILD_LIST ; do echo "  $EACH" ; done ; unset EACH
				echo ""
			fi
			if [[ -z "$INACTIVECHILD_LIST" ]] ; then
				echo "$CURRENTMASTER has no inactive linked children."
				echo ""
			else
				echo "Inactive linked children of $CURRENTMASTER: "
				for EACH in $INACTIVECHILD_LIST ; do echo "  $EACH" ; done ; unset EACH
				echo ""
			fi
			#
			# Shut down active/running children.
			f_autoupdate_stopactivechildren
			#
			# Update the master.
			echo "Updating master installation: $CURRENTMASTER"
			IN_INSTALLID="$CURRENTMASTER"
			f_update ; X_UPDATE_MAIN="$?"
			# Depending upon the updater success or failure, we continue or shut everything down.
			if [[ "$X_UPDATE_MAIN" == 0 ]] ; then
				# For ACTIVECHILD_LIST, we need to relink and start.
				# For INACTIVECHILD_LIST, we need to relink, but not start.
				#
				for EACH in $INACTIVECHILD_LIST ; do
					echo "Relinking linked child installation: $EACH"
					IN_INSTALLID="$EACH"
					f_relink 1> /dev/null
				done ; unset EACH IN_INSTALLID
				for EACH in $ACTIVECHILD_LIST ; do
					echo "Relinking and restarting linked child installation: $EACH"
					IN_INSTALLID="$EACH"
					f_relink 1> /dev/null
					f_start 1> /dev/null
				done ; unset EACH IN_INSTALLID
			else
				echoerr "Marking the installation ALLOWUPDATE=0. This will prevent further update attempts."
				echoerr "Manual intervention will be required to fix this."
				$SQLCMD "update inst set ALLOWUPDATE='0' where INSTALLID='$CURRENTMASTER';"
				# FIXME: need to mark the master as unrunnable, and children need to respect that it is in a broken state.
			fi
	
		echo ""
		unset IN_INSTALLID GAMETYPE ALLCHILD_LIST ACTIVECHILD_LIST INACTIVECHILD_LIST
		done ; unset CURRENTMASTER IN_INSTALLID
	fi
	#
	echo ""
	echo "Finish time is: $(date), RUNID=$RUNID"
	echo ""
	#
	# FIXME: Need to close the logfile tee.
	#
	if [[ ! "$AUTOUPDATING_SEEN_UPDATES" = 1 ]] ; then
		# If nothing interesting happened, let's just delete the log file, since we don't care.
		rm -f "$AUTOUPDATE_LOGFILE"
	else
		# Send an email with the log file.
		if [[ "$SEEN_ERRORS" == 1 ]] ; then
			AUTOUPDATE_MAIL_SUBJ="with errors"
			AUTOUPDATE_MAIL_MESSAGE="WARNING: Erorrs/warnings seen during update. Please review attached log file."
		else
			AUTOUPDATE_MAIL_SUBJ="successfully"
			AUTOUPDATE_MAIL_MESSAGE="Autoupdate completed successfully. Please review attached log file."
		fi
		$MAILER -s "$MAIL_SUBJ_PREFIX autoupdate $RUNID finished $AUTOUPDATE_MAIL_SUBJ" -a $AUTOUPDATE_LOGFILE $AUTOUPDATE_MAILTO <<-ENDMESSAGE
	
			Date: $(date)
			Master Update List: $MASTERUPDATE_LIST

			$AUTOUPDATE_MAIL_MESSAGE
	
		ENDMESSAGE
	fi
	# Remove the lock/PID file.
	rm -f "$AUTOUPDATE_LOCKFILE" &> /dev/null
	AUTOUPDATING=0
}

f_relink() {
	# Refresh the links on a linked/child installation to it's master installation.
	# This is basically the upgrade procedure for a linked installation.
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	# Verify that we are working on a linked installation. Quit otherwise.
	if [[ ! "$INSTTYPE" == linked ]] ; then
		echoerr ""
		echoerr "ERROR: $INSTALLID is not a linked installation type. Can not relink."
		echoerr ""
		return 1
	fi
	# If ALLOWUPDATE is not 1, do not allow relinking.
	if [[ ! "$ALLOWUPDATE" == 1 ]] ; then
		echoerr ""
		echoerr "ERROR: ALLOWUPDATE not set to allow updating on this installation. Can not relink."
		echoerr ""
		return 1
	fi
	#
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 && "$IN_PARAMS" != *"force" ]] ; then return 1 ; fi

	if [[ "$IN_PARAMS" == "force" ]] ; then
		echo ""
		echo "Forcefull relinking of $INSTALLID, this might crash the servers if binary files are updated"
	fi
	#
	# Test that a master exists. This is unlikely to be a problem, but it is possible.
	if [[ -z "$USEMASTER" ]] ; then
		echoerr ""
		echoerr "ERROR: No master installation for game type \"$GAMETYPE\" found in the database. Can not relink."
		echoerr ""
		return 1
	fi
	# Verify that the master installation directory exists, and err out if there is a problem.
	if [[ ! -d "$APPDIR/$USEMASTER" ]] ; then
		echoerr ""
		echoerr "ERROR: Master installation \"$USEMASTER\" found in the database, but no directory found at: $APPDIR/$USEMASTER"
		echoerr "  Can not relink."
		echoerr ""
		return 1
	fi
	echo ""
	echo -n "Relinking $INSTALLID to master $USEMASTER: "
	$NICECMD lns -q -r "$APPDIR/$USEMASTER/"* "$INSTALLDIR" ; X_LNS=$?
	if [[ ! "$X_LNS" == 0 ]] ; then
		echoerr ""
		echoerr "ERROR: Linking $INSTALLID to $USEMASTER failed. lns exit code $X_LNS."
		echoerr ""
		return 1
	fi
	echo "Done"
	echo ""
	#
	# Silently remove the InstallRecord.blob file, which is not relevant to linked installations.
	# FIXME: I think only HLDSUpdateTool did this?
	$NICECMD rm -f "$INSTALLDIR/InstallRecord.blob" 2> /dev/null
	# FIXME: Should add a blacklist file to delete files which exist in the master but are not wanted in the linked/child install.
	#   Alternatively, an overlay filesystem would do this.
	#
	# Remove old dangling symlinks
	echo "Looking for old dangling symlinks and removing them: "
	symlinks -d -r "$INSTALLDIR"
	echo "Done"
	# NOTE: We don't delete old empty directories, because we have no way to identify them. Could use "find -type d -empty" though.
	#
	# Delete the SteamCMD temp directories from linked installs. These are the 40-character 0-9a-f directories (SHA1?).
	for EACH in $(find "$INSTALLDIR" -maxdepth 1 -mindepth 1 -type d) ; do
		( EACHD=$(basename $EACH | egrep "^[0-9a-f]{40}$")
		if [[ -n "$EACHD" ]] ; then
			# echoerr "DEBUG: Found garbage SteamCMD tempdir in linked installation: $EACHD"
			# rm -rf "$INSTALLDIR/$EACHD"
			# The following commands are much safer than rm -rf.
			# echoerr "DEBUG: 1 $NICECMD find \"$INSTALLDIR/$EACHD\" -type l -lname \"*../$USEMASTER/*\" -exec rm -f '{}' +"
			$NICECMD find "$INSTALLDIR/$EACHD" -type l -lname "*../$USEMASTER/*" -exec rm -f '{}' +
			# echoerr "DEBUG: 2 $NICECMD find \"$INSTALLDIR/$EACHD\" -type d -empty -delete"
			$NICECMD find "$INSTALLDIR/$EACHD" -type d -empty -delete
		fi )
	done ; unset EACH EACHD
	#
	echo ""
	echo "Relinking $INSTALLID complete."
	echo ""

}

f_delink() {
	# Delete the links from a linked/child installation to it's master installation.
	# NOTE: This should not touch other links which are not related to the master.
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	# Verify that we are working on a linked installation. Quit otherwise.
	if [[ ! "$INSTTYPE" == linked ]] ; then
		echoerr ""
		echoerr "ERROR: $INSTALLID is not a linked installation type. Can not delink."
		echoerr ""
		return 1
	fi
	#
	# Test that a master exists. This is unlikely to be a problem, but it is possible.
	# Note that we do not test for a removed master, since that is a valid scenario.
	if [[ -z "$USEMASTER" ]] ; then
		echoerr ""
		echoerr "ERROR: No master installation for game type \"$GAMETYPE\" found in the database. Can not delink."
		echoerr ""
		return 1
	fi
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 ]] ; then return 1 ; fi
	#
	echo ""
	echo "This will delete all symbolic links in the $INSTALLID installation directory which refer to the master $USEMASTER."
	echo "This will NOT delete symbolic links which refer to other locations."
	echo ""
	echo "Are you sure you want to do this?"
	echo ""
	echo "VERIFICATION: Delink $INSTALLID from $USEMASTER ?"
	read -e -r -p "y/N: " -i "" REPLY 
	if [[ ! "$REPLY" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	echo ""
	#
	# NOTE: This is not completely safe. We are depending upon that -lname pattern, but it's close enough
	$NICECMD find "$INSTALLDIR" -type l -lname "*../$USEMASTER/*" -exec rm -f '{}' +
	echo "Delinking completed with exit code $?"
	echo ""
	# Also offer to delete worthless empty directories that lns created during the linking process.
	echo "Would you also like to delete all empty directories in the $INSTALLID installation directory?"
	echo "This includes ALL directories which are empty of anything other than additionally nested empty directories."
	echo ""
	echo "VERIFICATION: Delete empty directories in $INSTALLID ?"
	read -e -r -p "y/N: " -i "" REPLY
	if [[ ! "$REPLY" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	else
		find "$INSTALLDIR" -type d -empty -delete
		echo ""
		echo "Done deleting empty directories."
		echo ""
	fi
	# FIXME: We should probably mark this installation as ALLOWSTART=0 in the inst table.
}

f_allorone() {
	if [[ "$IN_INSTALLID" != "all" ]] ; then
		f_validate_installid
		$1 $2
	else
		SRV_LIST=$($SQLCMD "select INSTALLID from inst where INSTTYPE='linked';")
		for SRV_CHILD in $SRV_LIST ; do
			IN_INSTALLID=$SRV_CHILD
			f_validate_installid
			f_loaddbinst
			$1 $SRV_CHILD
		done
	fi
}

f_cleandemos() {
	# Manage SourceTV demo/autorecord files.
	# 
	local DEMOARCHIVE
	#
	DEMOARCHIVE="$GAMEDIR/demos"
	#
	echo -n "Cleaning up SourceTV demos: "
	# If there isn't a "demos" dir to organize our .demo files into, create one.
	if [[ ! -d "$DEMOARCHIVE" ]] ; then
			echo ""
			echo "$DEMOARCHIVE does not exist. Creating it now."
			$NICECMD mkdir "$DEMOARCHIVE" && chmod 770 "$DEMOARCHIVE" || { 
				echoerr "ERROR: Unable to create demos archive."
				return 1
			}
	fi
	# Delete old compressed demos.
	$NICECMD find $DEMOARCHIVE -maxdepth 1 -type f -name "*auto-*.dem.bz2" -mtime +$DEMOSEXPIRE -exec rm -f '{}' +
	#
	# Move newly created demos into the archive.
	$NICECMD find $GAMEDIR -maxdepth 1 -type f -name "*auto-*.dem" -cmin +3 -exec mv -t $DEMOARCHIVE '{}' +
	#
	# Compress demos in the archive.
	$NICECMD find $DEMOARCHIVE -maxdepth 1 -type f -name "auto-*.dem" -exec bzip2 '{}' \;
	#
	echo "Done"
}

f_cleanlogs() {
	# Manage logfiles.
	# There are lots of different logs. There's the "log" files, the "con_logfile" files, SourceMod log files, and wrench itself may write a log.
	#
	local LOGARCHIVE
	#
	LOGARCHIVE="$GAMEDIR/logs"
	#
	echo -n "Cleaning up logfiles: "
	if [[ ! -d "$LOGARCHIVE" ]] ; then
			echo ""
			echo "$LOGARCHIVE does not exist. Creating it now."
			$NICECMD mkdir "$LOGARCHIVE" && chmod 770 "$LOGARCHIVE" || {
				echoerr "ERROR: Unable to create log archive."
				return 1
			}
	fi
	# Delete old compressed logs.
	$NICECMD find $LOGARCHIVE -maxdepth 1 -type f -name "*.log.bz2" -mtime +$LOGSEXPIRE -exec rm -f '{}' +
	#
	# The console log is special in that it is never closed by the srcds server. We must copy it and then clear it until the next rotation.
	if [[ -f $GAMEDIR/console.log ]] ; then
		# Note that the timestamp on the log file is from when we collect it, not when it was opened/created.
		$NICECMD cp -ap -n $GAMEDIR/console.log $LOGARCHIVE/console-$(date +%Y%m%d%H%M%S).log && echo "" > $GAMEDIR/console.log
	fi
	#
	# Compress log files.
	$NICECMD find $LOGARCHIVE -maxdepth 1 -type f -name "*.log" -mtime +1 -exec bzip2 '{}' \;
	#
	# Handle CSGO's backup_round files, which are a sort of log (backup_round01.txt, backup_round02.txt,...).
	if [[ "$GAMEYTPE" == csgo ]] ; then
		# Delete the old files.
		$NICECMD find $LOGARCHIVE -maxdepth 1 -type f -name "*.txt.bz2" -mtime +$LOGSEXPIRE -exec rm -f '{}' +
		# Move the new files into the archive.
		$NICECMD find $GAMEDIR -maxdepth 1 -type f -name "backup_round*.txt" -cmin +3 -exec mv -t $LOGARCHIVE '{}' +
		# Compress the archive.
		$NICECMD find $LOGARCHIVE -maxdepth 1 -type f -name "backup_round*.txt" -mtime +1 -exec bzip2 '{}' \;
	fi
	#
	# wrench itself writes logs under certain conditions.
	CLEANUP_CAPTUREPANE_LOGS=0 # Set to 1 to clean up at the same schedule as other logs.
	if [[ "$CLEANUP_CAPTUREPANE_LOGS" == 1 ]] ; then
		$NICECMD find $INSTALLDIR -maxdepth 1 -type f -name "crash_capture-pane_[0-9]*-[0-9]*.log" -mtime +$LOGSEXPIRE -exec rm -f '{}' +
		$NICECMD find $INSTALLDIR -maxdepth 1 -type f -name "debug_capture-pane_[0-9]*-[0-9]*.log" -mtime +$LOGSEXPIRE -exec rm -f '{}' +
	fi
	#
	echo "Done"
}

f_cleandownloads() {
	# Clean up downloads files. This usually means sprays.
	#
	if [[ -d "$GAMEDIR/download/user_custom" ]] ; then
		echo -n "Cleaning up download/user_custom files: "
		# Delete old cache files.
		$NICECMD find $GAMEDIR/download/user_custom -maxdepth 2 -type f -name "????????.dat" -mtime +$DOWNLOADSEXPIRE -exec rm -f '{}' +
		$NICECMD find $GAMEDIR/download/user_custom -maxdepth 2 -type f -name "*.ztmp" -mtime +$DOWNLOADSEXPIRE -exec rm -f '{}' +
		# Also delete empty directories
		$NICECMD find $GAMEDIR/download/user_custom -mindepth 1 -maxdepth 1 -type d -empty -delete
		echo "Done"
	fi
}

f_cleanreplays() {
	# Clean up old replay files, since srcds does a very poor job of doing that itself.
	#
	# Do nothing if REPLAY_ENABLED=0.
	if [[ "$REPLAY_ENABLED" == 0 ]] ; then
		return 0
	fi
	echo -n "Cleaning up replay files: "
	if [[ -d "$GAMEDIR/replay/server/blocks" ]] ; then
		$NICECMD find $GAMEDIR/replay/server/blocks -maxdepth 1 -type f -name "*.dmx" -mtime +$REPLAYSEXPIRE -exec rm -f '{}' +
		$NICECMD find $GAMEDIR/replay/server/sessions -maxdepth 1 -type f -name "*.dmx" -mtime +$REPLAYSEXPIRE -exec rm -f '{}' +
	fi
	# Clean up the public-accessible www dir
	if [[ -d "$REPLAYBASEDIR/$CLEANTARGET/replay" ]] ; then
		$NICECMD find $REPLAYBASEDIR/$CLEANTARGET/replay -maxdepth 1 -type f -name "*.dmx" -mtime +$REPLAYSEXPIRE -exec rm -f '{}' +
		$NICECMD find $REPLAYBASEDIR/$CLEANTARGET/replay -maxdepth 1 -type f -name "*.block" -mtime +$REPLAYSEXPIRE -exec rm -f '{}' +
	fi
	echo "Done"
}

f_cleaninstall() {
	# "Clean" an installation by deleting old cache files, compressing and rotating logs/demos, et-cetera.
	# FIXME: We need a persistant failure variable, like SEEN_CLEANUP_FAIL and return 1 if seen anywhere in any sub fuc.
	#
	local CLEANTARGET
	#
	CLEANTARGET="$IN_INSTALLID"
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	#
	# Never try to clean a master install.
	if [[ "$INSTTYPE" == master ]] ; then
		[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
		echoerr "ERROR: Can not clean $CLEANTARGET because it is a $INSTTYPE type installation."
		[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
		return 1
	fi
	# Validate the GAMEDIR before proceeding.
	if [[ ! -d "$GAMEDIR" ]] ; then
		[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
		echoerr "ERROR: GAMEDIR for \"$CLEANTARGET\" not found. Unable to clean installation."
		[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
		return 1
	fi
	#
	[[ "$SEEN_AUTOCLEAN" == 1 ]] || echo ""
	# echoerr "DEBUG: Cleanup target $CLEANTARGET GAMETYPE=$GAMETYPE"
	# 
	# cd to /tmp for safety reasons.
	cd /tmp
	#
	# Each GAMETYPE is different. For example, only TF2 supports replays at this time.
	case "$GAMETYPE" in
		'css')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
			f_cleandownloads
		;;
		'hl2dm')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
			f_cleandownloads
		;;
		'l4d')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
		;;
		'l4d2')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
		;;
		'tf2')
			echo "cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
			f_cleandownloads
			f_cleanreplays
		;;
		'fof')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
			f_cleandownloads
		;;
		'csgo')
			echo "Cleaning up $CLEANTARGET... "
			f_cleandemos
			f_cleanlogs
		;;
		'gmod')
			echo "Cleaning up $CLEANTARGET... "
			f_cleanlogs
			f_cleandownloads
		;;
		*)
			[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
			echoerr "$CLEANTARGET: GAMETYPE \"$GAMETYPE\" not supported for cleanup."
			[[ "$SEEN_AUTOCLEAN" == 1 ]] || echoerr ""
			return 2
	esac
	#
	echo "Finished cleaning $CLEANTARGET."
	[[ "$SEEN_AUTOCLEAN" == 1 ]] || echo ""
}

f_autocleanup() {
	# Automatically cleans up all installations marked via the "AUTOCLEAN" column in the inst table.
	#
	local AUTOCLEANUP_LIST 
	#
	# Get the full list of runnable srcds installs. Excludes masters, then figure out which should be cleaned.
	AUTOCLEANUP_LIST=$($SQLCMD "select INSTALLID from inst where AUTOCLEANUP='1' and not INSTTYPE='master';")
	# echoerr "DEBUG: autocleanup target list is: $AUTOCLEANUP_LIST"
	SEEN_AUTOCLEAN=1 # Fix spacing when looping via autoclean
	for AUTOCLEANTARGET in $AUTOCLEANUP_LIST ; do
		IN_INSTALLID="$AUTOCLEANTARGET"
		echo ""
		f_cleaninstall
	done ; unset AUTOCLEANTARGET
	echo ""
}

f_lockcheck() {
	# Check if a lock has been placed on the installation to prevent a train wreck.
	#
	# FIXME: We also need to check the master to be sure it is not being updated.
	if [[ -f "$LOCKFILE" ]] ; then
		LOCKFAIL=1
		echoerr ""
		echoerr "ERROR: lockfile active. Check to see if some other process is working on this installation."
		echoerr "  Lockfile: $LOCKFILE"
		echoerr ""
		return 1
	fi
}

f_uninstall() {
	# Uninstall/remove a server instance.
	# FIXME: This entire process needs review.
	#
	local INSTALLATIONS_LIST INSTALLATIONS_LIST UNINSTALL_SELECT IN_INSTALLID X_INSTDBDELETE X_UNLOCKMASTER
	#
	echo ""
	echo "This will completely remove a srcds installation, including the database entry and installation directory."
	echo "WARNING: If you uninstall a master installation, any linked children installations will become broken."
	echo ""
	echo "  The following installations were found in the DB. If the installation you are looking "
	echo "  for isn't here, then it may have already been removed from the database or is invalid."
	echo ""
	INSTALLATIONS_LIST=$($SQLCMD "select INSTALLID from inst;")
	echo "Please choose an installation to uninstall/delete:"
	echo ""
	select UNINSTALL_SELECT in $INSTALLATIONS_LIST QUIT ; do
		if [[ -z "$UNINSTALL_SELECT" ]] ; then
			echo "Invalid entry. Try again."
			continue
		fi
		if [[ "$UNINSTALL_SELECT" == "QUIT" ]] ; then
			echo ""
			echo "Quitting."
			echo ""
			return 1
		fi
		echo "For verification, please type the exact name of the installation you just selected."
		read -e -r -p "Name: " -i "" IN_UNINSTALL
		if [[ "$UNINSTALL_SELECT" == "$IN_UNINSTALL" ]] ; then
			break
		else
			echo "Verification failed. Try again?"
			continue
		fi
	done
	echo ""
	echo "FINAL VERIFICATION: Delete ${UNINSTALL_SELECT}?"
	read -e -r -p "y/N: " -i "" IN_UNINSTALLFINAL
	if [[ ! "$IN_UNINSTALLFINAL" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	echo ""
	#
	# FIXME: If certain tests in f_loaddb fail, we may not be able to uninstall. Need to review this.
	IN_INSTALLID="$UNINSTALL_SELECT"
	f_loaddbinst # Load the DB inst info here.
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	#
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 ]] ; then return 1 ; fi
	#
	f_lockcheck # Make sure there isn't a lock on the installation.
	if [[ "$LOCKFAIL" == 1 ]] ; then return 1 ; fi
	#
	echo -n "Deleting database record: "
	$SQLCMD "delete from inst where INSTALLID='$UNINSTALL_SELECT';" ; X_INSTDBDELETE=$?
	if [[ ! "$X_INSTDBDELETE" == 0 ]] ; then
		echoerr ""
		echoerr "WARNING: Request to delete \"$UNINSTALL_SELECT\" from the database failed. Exit code $X_INSTDBDELETE. Continuing anyway."
	fi
	echo "Done"
	#
	# If this is a master type installation, we must unlock it before we try to delete the installation directory.
	if [[ "$INSTTYPE" == "master" ]] ; then
		f_unlockmaster ; X_UNLOCKMASTER="$?" # Unlock the master for writing.
		if [[ ! "$X_UNLOCKMASTER" == 0 ]] ; then return 1 ; fi
	fi
	#
	if [[ -d "$APPDIR/$UNINSTALL_SELECT" ]] ; then	
		echo -n "Removing installation directory: "
		rm -rf "$APPDIR/$UNINSTALL_SELECT" || ( echoerr "WARNING: Error while removing installation directory. Continuing anyway." )
		echo "Done"
	else
		echoerr "WARNING: Installation dir $APPDIR/$UNINSTALL_SELECT not found. Continuing anyway."
	fi
	#
	if [[ "$REPLAY_ENABLED" == 1 ]] && [[ -d "$REPLAYBASEDIR/$UNINSTALL_SELECT" ]] ; then
		echo -n "Removing the replay web server directory: "
		rm -rf "$REPLAYBASEDIR/$UNINSTALL_SELECT" || ( echoerr "WARNING: Error while removing replay web server directory. Continuing anyway." )
		echo "Done"
	fi
	echo ""
	echo "$UNINSTALL_SELECT uninstall completed."
	echo ""
}

f_deletegametype() {
	# FIXME: This is not yet used.
	# Delete a GAMETYPE from the srcinfo table.
	#
	local GAMETYPES_LIST GAMETYPEDEPENDANCY_LIST X_DELETEGAMETYPE
	#
	echo ""
	echo "This process will delete a srcds game type from the database."
	echo ""
	echo "Please choose which game type you wish to delete:"
	echo ""
	GAMETYPES_LIST=$($SQLCMD "select GAMETYPE from srcinfo;")
	select DELETEGAMETYPE_SELECT in $GAMETYPES_LIST QUIT ; do
		if [[ -z "$DELETEGAMETYPE_SELECT" ]] ; then
			echo "Invalid entry. Try again."
			continue
		fi
		if [[ "$DELETEGAMETYPE_SELECT" == "QUIT" ]] ; then
			echo ""
			echo "Quitting."
			echo ""
			return 1
		fi
		echo "For verification, please type the exact name of the game type you just selected."
		read -e -r -p "Name: " -i "" IN_DELETE
		if [[ "$DELETEGAMETYPE_SELECT" == "$IN_DELETE" ]] ; then
			break
		else
			echoerr ""
			echoerr "Verification failed."
			echoerr ""
			return 1
		fi
	done
	echo ""
	# There must be no leftover dependancy upon the GAMETYPE. If there is one, fail.
	GAMETYPEDEPENDANCY_LIST=$($SQLCMD "select INSTALLID from inst where GAMETYPE='$DELETEGAMETYPE_SELECT';")
	if [[ -n "$GAMETYPEDEPENDANCY_LIST" ]] ; then
		echoerr "ERROR: Unable to delete \"$DELETEGAMETYPE_SELECT\" from the database."
		echoerr "  A game type can not be deleted so long as at least one installation of it's type remains."
		echoerr ""
		echoerr "  The following installations belong to this game type: "
		echoerr ""
		echoerr "  $(echo $GAMETYPEDEPENDANCY_LIST | tr '\n' ' ')"
		echoerr ""
		echoerr "Quitting."
		echoerr ""
		return 1
	fi
	echo "FINAL VERIFICATION: Delete ${DELETEGAMETYPE_SELECT}?"
	read -e -r -p "y/N: " -i "" IN_DELETEFINAL
	if [[ ! "$IN_DELETEFINAL" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	# 
	# Delete the GAMETYPE from the DB.
	echo ""
	echo -n "Deleting database record: "
	$SQLCMD "delete from srcinfo where GAMETYPE='$DELETEGAMETYPE_SELECT';" ; X_DELETEGAMETYPE="$?"
	if [[ ! "$X_DELETEGAMETYPE" == 0 ]] ; then
		echoerr ""
		echoerr "ERROR: Request to delete \"$DELETEGAMETYPE_SELECT\" from the database failed. Exit code $X_DELETEGAMETYPE."
		echoerr ""
		return 1
	fi
	echo "Done"
	echo ""
	echo "Game type successfully deleted."
	echo ""
	return 0
}

f_choosename() {
	# Name an installation. We use this on first-time installations(f_installnewlinked), and renames(f_rename).
	#
	echo ""
	echo "Valid characters are a-z, A-Z, and 0-9. No other characters allowed."
	echo "An automatically-generated prefix will be prepended to the installation name."
	echo "For example: If you enter \"MyTest1\" and the game type is tf2, the "
	echo "new installation's full name will be \"tf2-MyTest1\"."
	echo ""
	while read -e -r -p "Suffix Name: " -i "" IN_NEWSUFFIX ; do
		# Validate the input.
		if [[ -z "$IN_NEWSUFFIX" ]] || (echo "$IN_NEWSUFFIX" | egrep "[[:cntrl:]]|[[:punct:]]|[[:space:]]" &> /dev/null ) ; then
			echo ""
			echo "Invalid input detected. Try again."
		else
			# Our INSTALLID will be set as IN_INSTALLNAME
			IN_INSTALLNAME=${GAMETYPE}-${IN_NEWSUFFIX}
			#
			# Verify that there isn't an existing installation by that name.
			INSTALLID_CHECK=$($SQLCMD "select INSTALLID from inst where INSTALLID='$IN_INSTALLNAME';")
			if [[ "$INSTALLID_CHECK" == "$IN_INSTALLNAME" ]] ; then
				echoerr ""
				echoerr "ERROR: There is already a srcds installation named \"$IN_INSTALLNAME\" in the database."
				echoerr "  Chose another name or remove the offending conflict."
				echoerr ""
				continue
			elif [[ -d "$APPDIR/$IN_INSTALLNAME" ]] ; then
				echoerr ""
				echoerr "ERROR: There is already a directory at \"$APPDIR/$IN_INSTALLNAME\"."
				echoerr "  Chose another name or remove the offending conflict."
				echoerr ""
				continue
			fi
			#
			echo ""
			echo "Please confirm: The new installation name will be \"$IN_INSTALLNAME\"?"
			# echo -n "y/N: "
			read -e -r -p "y/N: " -i "" IN_NEWSUFFIX_CONFIRM
			if [[ "$IN_NEWSUFFIX_CONFIRM" == [yY] ]]; then
				break
			else
				echo ""
				echo "Okay then, let's try again. What name do you want?"
			fi

		fi
	done ; unset INSTALLID_CHECK
}

f_configinstall() {
	# Configure an installation. We may be installing a new install, or reconfiguring an existing one.
	# We get called by either f_installnewlinked or f_reconfig.
	#Note that master installs have their own function, f_installnewmaster, for NEW installs, but can be reconfigured.
	#
	local X_INSTALLDBINSERT X_RECONFIGINST
	#
	# If configuring as new(install), then use the srcinfo INSTDEF_.
	# If configuring as a reconfig(reconfig), then use the existing info from the DB.
	if [[ "$IN_ARG" == "install" ]] ; then
		# We will use the INSTDEF_ defaults from the srcinfo table to set defaults.
		# We should have already called f_loaddbsrcinfo from f_install.
		IPADDR=$INSTDEF_IPADDR
		CLIENTPORT=$INSTDEF_CLIENTPORT
		HOSTPORT=$INSTDEF_HOSTPORT
		TVPORT=$INSTDEF_TVPORT
		STEAMPORT=$INSTDEF_STEAMPORT
		ALLOWUPDATE=$INSTDEF_ALLOWUPDATE
		ALLOWSTART=$INSTDEF_ALLOWSTART
		BOOTSTART=$INSTDEF_BOOTSTART
		AUTOCLEANUP=$INSTDEF_AUTOCLEANUP
		MAILNOTIFY=$INSTDEF_MAILNOTIFY
		HIPCHATNOTIFY=$INSTDEF_HIPCHATNOTIFY
		MAILTO=$INSTDEF_MAILTO
		STARTBIN=$INSTDEF_STARTBIN
		EVALTXT_STARTBINARGS=$INSTDEF_STARTBINARGS
		RECOVER_CRASH_ENABLE="$INSTDEF_RECOVER_CRASH_ENABLE"
		RECOVER_WATCHDOG_ENABLE="$INSTDEF_RECOVER_WATCHDOG_ENABLE"
		RECOVER_WATCHDOG_TEST_INTERVAL="$INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL"
		RECOVER_WATCHDOG_POLL_MAX="$INSTDEF_RECOVER_WATCHDOG_POLL_MAX"
		RECOVER_WATCHDOG_START_WAIT="$INSTDEF_RECOVER_WATCHDOG_START_WAIT"
		RECOVER_SLEEP="$INSTDEF_RECOVER_SLEEP"
		INSTTYPE="linked" # We need to specify that this will be a linked install for new linked installations.
	elif [[ "$IN_ARG" == "reconfig" ]] ; then
		# f_reconfig should have already called f_loaddbinst, but we set IN_ params to defaults. This is important for master reconfigs.
		# We should be using the DB_ values here, not the resulting values. For example, MAILTO might be changed when it should not be.
		IPADDR=$DB_IPADDR
		CLIENTPORT=$DB_CLIENTPORT
		HOSTPORT=$DB_HOSTPORT
		TVPORT=$DB_TVPORT
		STEAMPORT=$DB_STEAMPORT
		ALLOWUPDATE=$DB_ALLOWUPDATE
		ALLOWSTART=$DB_ALLOWSTART
		BOOTSTART=$DB_BOOTSTART
		AUTOCLEANUP=$DB_AUTOCLEANUP
		MAILNOTIFY=$DB_MAILNOTIFY
		MAILTO=$DB_MAILTO
		STARTBIN=$DB_STARTBIN
		EVALTXT_STARTBINARGS=$DB_STARTBINARGS
		RECOVER_CRASH_ENABLE="$DB_RECOVER_CRASH_ENABLE"
		RECOVER_WATCHDOG_ENABLE="$DB_RECOVER_WATCHDOG_ENABLE"
		RECOVER_WATCHDOG_TEST_INTERVAL="$DB_RECOVER_WATCHDOG_TEST_INTERVAL"
		RECOVER_WATCHDOG_POLL_MAX="$DB_RECOVER_WATCHDOG_POLL_MAX"
		RECOVER_WATCHDOG_START_WAIT="$DB_RECOVER_WATCHDOG_START_WAIT"
		RECOVER_SLEEP="$DB_RECOVER_SLEEP"
		INSTVER="$DB_INSTVER"
		INSTVER_METHOD="$DB_INSTVER_METHOD"
	fi
	#
	case "$INSTTYPE" in 'linked')
		echo ""
		echo "What shall be the Installation IP Address? (-ip)"
		echo "  NOTE: To bind to all local IP addresses, use \"0.0.0.0\"."
		echo "  NOTE: The following IP addresses were found on this host: "
		for EACH in $(ip route show table local 2> /dev/null | egrep "^local " | cut -f 2 -d " " | egrep -v "^127\.0\." | sort -V | uniq) ; do
			echo "    $EACH"
		done ; unset EACH
		echo ""
		while read -e -r -p "IPADDR: " -i "$IPADDR" IN_IPADDR ; do
			# Filter invalid characters and validate input.
			IN_IPADDR=$(echo "$IN_IPADDR" | tr -c -d '[:digit:].')
			if [[ -z "$IN_IPADDR" ]] || (echo "$IN_IPADDR" | egrep -v "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "What shall be the Installation Host Port? (+hostport)"
		while read -e -r -p "HOSTPORT: " -i "$HOSTPORT" IN_HOSTPORT ; do
			# Filter invalid characters and validate input.
			IN_HOSTPORT=$(echo "$IN_HOSTPORT" | tr -c -d '[:digit:]')
			if [[ -z "$IN_HOSTPORT" ]] || [[ "$IN_HOSTPORT" -lt 1024 ]] || [[ "$IN_HOSTPORT" -gt 49151 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				LIST_PORTS=$($SQLCMD "select hostport from inst;")
				HP_BAD=0
				for EACH_PORT in $LIST_PORTS ; do
					if [[ "$IN_HOSTPORT" == @($EACH_PORT|$[$EACH_PORT+1]|$[$EACH_PORT+2]|$[$EACH_PORT+3]) ]] ; then
						echo ""
						echo "Port overlaps or too close to another instance port. Choose another port!"
						HP_BAD=1
					fi
				done
				if [[ "$HP_BAD" != "1" ]] ; then
					break
				fi
			fi
		done
		if [[ "$HOSTPORT" != "$IN_HOSTPORT" ]]; then
			CLIENTPORT="$[IN_HOSTPORT+1]"
			TVPORT="$[IN_HOSTPORT+2]"
			STEAMPORT="$[IN_HOSTPORT+3]"
		fi
		echo ""
	esac
	#
        case "$INSTTYPE" in 'linked')
                echo "What shall be the Installation Client Port? (+clientport)"
                while read -e -r -p "CLIENTPORT: " -i "$CLIENTPORT" IN_CLIENTPORT ; do
                        # Filter invalid characters and validate input.
                        IN_CLIENTPORT=$(echo "$IN_CLIENTPORT" | tr -c -d '[:digit:]')
                        if [[ -z "$IN_CLIENTPORT" ]] || [[ "$IN_CLIENTPORT" -lt 1024 ]] || [[ "$IN_CLIENTPORT" -gt 49151 ]] ; then
                                echo ""
                                echo "Invalid input detected. Try again."
                        else
                                break
                        fi
                done
                echo ""
        esac
        #
	case "$INSTTYPE" in 'linked')
		echo "What shall be the Installation TV Port? (+tv_port)"
		while read -e -r -p "TVPORT: " -i "$TVPORT" IN_TVPORT ; do
			# Filter invalid characters and validate input.
			IN_TVPORT=$(echo "$IN_TVPORT" | tr -c -d '[:digit:]')
			if [[ -z "$IN_TVPORT" ]] || [[ "$IN_TVPORT" -lt 1024 ]] || [[ "$IN_TVPORT" -gt 49151 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "What shall be the Installation Steam Port? (-steamport)"
		while read -e -r -p "STEAMPORT: " -i "$STEAMPORT" IN_STEAMPORT ; do
			# Filter invalid characters and validate input.
			IN_STEAMPORT=$(echo "$IN_STEAMPORT" | tr -c -d '[:digit:]')
			if [[ -z "$IN_STEAMPORT" ]] || [[ "$IN_STEAMPORT" -lt 1024 ]] || [[ "$IN_STEAMPORT" -gt 49151 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
			break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked'|'master') # Allow masters to be reconfiged.
		echo "Is the installation Allowed to be Updated or Relinked? 1=yes 0=no"
		while read -e -r -p "ALLOWUPDATE: " -i "$ALLOWUPDATE" IN_ALLOWUPDATE ; do
			# Filter invalid characters and validate input.
			IN_ALLOWUPDATE=$(echo "$IN_ALLOWUPDATE" | tr -c -d '[:digit:]')
			if [[ -z "$IN_ALLOWUPDATE" ]] || (echo "$IN_ALLOWUPDATE" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Is the installation Allowed to Start? 1=yes 0=no"
		while read -e -r -p "ALLOWSTART: " -i "$ALLOWSTART" IN_ALLOWSTART ; do
			# Filter invalid characters and validate input.
			IN_ALLOWSTART=$(echo "$IN_ALLOWSTART" | tr -c -d '[:digit:]')
			if [[ -z "$IN_ALLOWSTART" ]] || (echo "$IN_ALLOWSTART" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Is the installation Allowed to start at Boot? 1=yes 0=no"
		while read -e -r -p "BOOTSTART: " -i "$BOOTSTART" IN_BOOTSTART ; do
			# Filter invalid characters and validate input.
			IN_BOOTSTART=$(echo "$IN_BOOTSTART" | tr -c -d '[:digit:]')
			if [[ -z "$IN_BOOTSTART" ]] || (echo "$IN_BOOTSTART" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Is the installation Allowed to Auto Cleanup? 1=yes 0=no"
		while read -e -r -p "AUTOCLEANUP: " -i "$AUTOCLEANUP" IN_AUTOCLEANUP ; do
			# Filter invalid characters and validate input.
			IN_AUTOCLEANUP=$(echo "$IN_AUTOCLEANUP" | tr -c -d '[:digit:]')
			if [[ -z "$IN_AUTOCLEANUP" ]] || (echo "$IN_AUTOCLEANUP" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Is the installation Allowed to send Mail Notifications? 1=yes 0=no"
		while read -e -r -p "MAILNOTIFY: " -i "$MAILNOTIFY" IN_MAILNOTIFY ; do
			# Filter invalid characters and validate input.
			IN_MAILNOTIFY=$(echo "$IN_MAILNOTIFY" | tr -c -d '[:digit:]')
			if [[ -z "$IN_MAILNOTIFY" ]] || (echo "$IN_MAILNOTIFY" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
        case "$INSTTYPE" in 'linked')
                echo "Is the installation Allowed to send Hipchat Notifications? 1=yes 0=no"
                while read -e -r -p "HIPCHATNOTIFY: " -i "$HIPCHATNOTIFY" IN_HIPCHATNOTIFY ; do
                        # Filter invalid characters and validate input.
                        IN_HIPCHATNOTIFY=$(echo "$IN_HIPCHATNOTIFY" | tr -c -d '[:digit:]')
                        if [[ -z "$IN_HIPCHATNOTIFY" ]] || (echo "$IN_HIPCHATNOTIFY" | egrep -v "^0$|^1$" &> /dev/null ) ; then
                                echo ""
                                echo "Invalid input detected. Try again."
                        else
                                break
                        fi
                done
                echo ""
        esac
	#
	case "$INSTTYPE" in 'linked')
		echo "What is the installation's Notification Email address? (leave blank to use default)"
		while read -e -r -p "MAILTO: " -i "$MAILTO" IN_MAILTO ; do
			# Filter invalid characters and validate input.
			IN_MAILTO=$(echo "$IN_MAILTO" | tr -d '"[:blank:][:cntrl:]') # FU IDN.
			if [[ -n "$IN_MAILTO" ]] && (echo "$IN_MAILTO" | egrep -v "^.+@.+$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Should the installation automatically recover after a crash? 1=yes 0=no"
		while read -e -r -p "RECOVER_CRASH_ENABLE: " -i "$RECOVER_CRASH_ENABLE" IN_RECOVER_CRASH_ENABLE ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_CRASH_ENABLE=$(echo "$IN_RECOVER_CRASH_ENABLE" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_CRASH_ENABLE" ]] || (echo "$IN_RECOVER_CRASH_ENABLE" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "Should the watchdog process monitor the installation while running? 1=yes 0=no"
		while read -e -r -p "RECOVER_WATCHDOG_ENABLE: " -i "$RECOVER_WATCHDOG_ENABLE" IN_RECOVER_WATCHDOG_ENABLE ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_WATCHDOG_ENABLE=$(echo "$IN_RECOVER_WATCHDOG_ENABLE" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_WATCHDOG_ENABLE" ]] || (echo "$IN_RECOVER_WATCHDOG_ENABLE" | egrep -v "^0$|^1$" &> /dev/null ) ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "How often should the watchdog poll the installation when running, measured in seconds?"
		while read -e -r -p "RECOVER_WATCHDOG_TEST_INTERVAL: " -i "$RECOVER_WATCHDOG_TEST_INTERVAL" IN_RECOVER_WATCHDOG_TEST_INTERVAL ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_WATCHDOG_TEST_INTERVAL=$(echo "$IN_RECOVER_WATCHDOG_TEST_INTERVAL" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_WATCHDOG_TEST_INTERVAL" ]] || [[ "$IN_RECOVER_WATCHDOG_TEST_INTERVAL" -gt 600 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "How many watchdog poll failures must occur before the installation is forcefully restarted?"
		while read -e -r -p "RECOVER_WATCHDOG_POLL_MAX: " -i "$RECOVER_WATCHDOG_POLL_MAX" IN_RECOVER_WATCHDOG_POLL_MAX ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_WATCHDOG_POLL_MAX=$(echo "$IN_RECOVER_WATCHDOG_POLL_MAX" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_WATCHDOG_POLL_MAX" ]] || [[ "$IN_RECOVER_WATCHDOG_POLL_MAX" -gt 99 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "How long should the watchdog wait before polling a newly started installation, in seconds?"
		while read -e -r -p "RECOVER_WATCHDOG_START_WAIT: " -i "$RECOVER_WATCHDOG_START_WAIT" IN_RECOVER_WATCHDOG_START_WAIT ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_WATCHDOG_START_WAIT=$(echo "$IN_RECOVER_WATCHDOG_START_WAIT" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_WATCHDOG_START_WAIT" ]] || [[ "$IN_RECOVER_WATCHDOG_START_WAIT" -gt 300 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "How long should the installation pause after a crash, in seconds?"
		while read -e -r -p "RECOVER_SLEEP: " -i "$RECOVER_SLEEP" IN_RECOVER_SLEEP ; do
			# Filter invalid characters and validate input.
			IN_RECOVER_SLEEP=$(echo "$IN_RECOVER_SLEEP" | tr -c -d '[:digit:]')
			if [[ -z "$IN_RECOVER_SLEEP" ]] || [[ "$IN_RECOVER_SLEEP" -gt 60 ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "What is the installation's Startup Binary?"
		while read -e -r -p "STARTBIN: " -i "$STARTBIN" IN_STARTBIN ; do
			# Filter invalid characters and validate input.
			IN_STARTBIN=$(echo "$IN_STARTBIN" | tr -d '[:cntrl:][:blank:]"`${}[]()<>?/\!*')
			if [[ -z "$IN_STARTBIN" ]] ; then
				echo ""
				echo "Invalid input detected. Try again."
			else
				break
			fi
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'linked')
		echo "IMPORTANT: STARTBINARGS allows and encourages you to use bash parameters/variables."
		echo "  These parameters will be expanded when you start the installation."
		echo "  For example, you can use \"+clientport \$CLIENTPORT\" and the CLIENTPORT field from the database will be used."
		echo "  You DO NOT need to escape or quote these values."
		echo ""
		echo "What is the installation's Startup Arguments?"
		while read -e -r -p "STARTBINARGS: " -i "$EVALTXT_STARTBINARGS" IN_STARTBINARGS ; do
			# Filter invalid characters and validate input.
			IN_STARTBINARGS=$(echo "$IN_STARTBINARGS" | tr -c -d '[:alnum:]$ [=-=].+_~/@')
			#if [[ -z "$IN_STARTBINARGS" ]] ; then
			#	echo ""
			#	echo "Invalid input detected. Try again."
			#else
			#	break
			#fi
			break
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'master')
		echo "What is the installation's game version?"
		while read -e -r -p "INSTVER: " -i "$INSTVER" IN_INSTVER ; do
			# Filter invalid characters and validate input.
			IN_INSTVER=$(echo "$IN_INSTVER" | tr -c -d '[:digit:]')
			if [[ -z "$IN_INSTVER" ]] || ( echo "$IN_INSTVER" | egrep -v "^[0-9]+$" &> /dev/null ) ; then
			       echo ""
			       echo "Invalid input detected. Try again."
			else
			       break
			fi
			break
		done
		echo ""
	esac
	#
	case "$INSTTYPE" in 'master')
		echo "What is the installation's game version tracking method? (db or steaminf)"
		while read -e -r -p "INSTVER_METHOD: " -i "$INSTVER_METHOD" IN_INSTVER_METHOD ; do
			# Filter invalid characters and validate input.
			IN_INSTVER_METHOD=$(echo "$IN_INSTVER_METHOD" | tr -c -d '[:alnum:]')
			if [[ -z "$IN_INSTVER_METHOD" ]] || ( echo "$IN_INSTVER_METHOD" | egrep -v "^db$|^steaminf$" &> /dev/null ) ; then
			       echo ""
			       echo "Invalid input detected. Try again."
			else
			       break
			fi
			break
		done
		echo ""
	esac
	#
	# User then reviews the info and confirms.
	echo "Please confirm: Is the following information correct?"
	echo ""
	( [[ "$INSTTYPE" == linked ]] && echo "  IP Address|:|$IN_IPADDR"
    [[ "$INSTTYPE" == linked ]] && echo "  Host Port|:|$IN_HOSTPORT"
	[[ "$INSTTYPE" == linked ]] && echo "  Client Port|:|$IN_CLIENTPORT"
	[[ "$INSTTYPE" == linked ]] && echo "  TV Port|:|$IN_TVPORT"
	[[ "$INSTTYPE" == linked ]] && echo "  Steam Port|:|$IN_STEAMPORT"
	[[ "$INSTTYPE" =~ ^linked$|^master$ ]] && echo "  Allow Update|:|$IN_ALLOWUPDATE"
	[[ "$INSTTYPE" == linked ]] && echo "  Allow Autostart|:|$IN_ALLOWSTART"
	[[ "$INSTTYPE" == linked ]] && echo "  Allow Bootstart|:|$IN_BOOTSTART"
	[[ "$INSTTYPE" == linked ]] && echo "  Auto-Cleanup|:|$IN_AUTOCLEANUP"
	[[ "$INSTTYPE" == linked ]] && echo "  Allow Notifications|:|$IN_MAILNOTIFY"
    [[ "$INSTTYPE" == linked ]] && echo "  Allow Hipchat Notifications|:|$IN_HIPCHATNOTIFY"
	[[ "$INSTTYPE" == linked ]] && echo "  Email Address|:|$IN_MAILTO"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Crash Enable|:|$IN_RECOVER_CRASH_ENABLE"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Watchdog Enable|:|$IN_RECOVER_WATCHDOG_ENABLE"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Watchdog Test Interval|:|$IN_RECOVER_WATCHDOG_TEST_INTERVAL"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Watchdog Max Tests|:|$IN_RECOVER_WATCHDOG_POLL_MAX"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Watchdog Start Wait|:|$IN_RECOVER_WATCHDOG_START_WAIT"
	[[ "$INSTTYPE" == linked ]] && echo "  Recovery Delay|:|$IN_RECOVER_SLEEP"
	[[ "$INSTTYPE" == linked ]] && echo "  Startup Binary|:|$IN_STARTBIN"
	[[ "$INSTTYPE" == linked ]] && echo "  Startup Arguments|:|$IN_STARTBINARGS"
	[[ "$INSTTYPE" == master ]] && echo "  Installation Version|:|$IN_INSTVER"
	[[ "$INSTTYPE" == master ]] && echo "  Installation Version Method|:|$IN_INSTVER_METHOD"
	) | column -t -s "|"
	echo ""
	echo "Would you like to proceed with recording these values?"
	read -e -r -p "y/N: " -i "" IN_FINAL_CONFIG_CONFIRM
		if [[ ! "$IN_FINAL_CONFIG_CONFIRM" == [yY] ]]; then
			echo ""
			echo "Quitting."
			echo ""
			return 2
		fi
	echo ""
	#
	# If we are here for a new install, we are going to do an SQL insert. If we are here for a reconfig, we do an update.
	if [[ "$IN_ARG" == "install" ]] ; then
		echo ""
		echo -n "Registering the installation into the database: "
		$SQLCMD "insert into 'inst' (INSTALLID, GAMETYPE, INSTTYPE, IPADDR, CLIENTPORT, HOSTPORT, TVPORT, STEAMPORT, ALLOWUPDATE, ALLOWSTART, BOOTSTART, AUTOCLEANUP, MAILNOTIFY, HIPCHATNOTIFY, MAILTO, STARTBIN, STARTBINARGS, RECOVER_CRASH_ENABLE, RECOVER_WATCHDOG_ENABLE, RECOVER_WATCHDOG_TEST_INTERVAL, RECOVER_WATCHDOG_POLL_MAX, RECOVER_WATCHDOG_START_WAIT, RECOVER_SLEEP) values ('$IN_INSTALLNAME', '$IN_INSTALLGAMETYPE', 'linked', '$IN_IPADDR', '$IN_CLIENTPORT', '$IN_HOSTPORT', '$IN_TVPORT', '$IN_STEAMPORT', '$IN_ALLOWUPDATE', '$IN_ALLOWSTART', '$IN_BOOTSTART', '$IN_AUTOCLEANUP', '$IN_MAILNOTIFY', '$IN_HIPCHATNOTIFY', '$IN_MAILTO', '$IN_STARTBIN', '$IN_STARTBINARGS', '$IN_RECOVER_CRASH_ENABLE', '$IN_RECOVER_WATCHDOG_ENABLE', '$IN_RECOVER_WATCHDOG_TEST_INTERVAL', '$IN_RECOVER_WATCHDOG_POLL_MAX', '$IN_RECOVER_WATCHDOG_START_WAIT', '$IN_RECOVER_SLEEP');"
		X_INSTALLDBINSERT=$?
		if [[ ! "$X_INSTALLDBINSERT" == 0 ]] ; then
			echoerr ""
			echoerr "ERROR: The database command returned exit code $X_INSTALLDBINSERT."
			echoerr "  Something went wrong when attempting to record the new installation."
			echoerr ""
			return 1
		else
			echo "Done"
		fi
	elif [[ "$IN_ARG" == "reconfig" ]] ; then
		echo -n "Registering the installation's new config into the database: "
		$SQLCMD "update inst set IPADDR='$IN_IPADDR', CLIENTPORT='$IN_CLIENTPORT', HOSTPORT='$IN_HOSTPORT', TVPORT='$IN_TVPORT', STEAMPORT='$IN_STEAMPORT', ALLOWUPDATE='$IN_ALLOWUPDATE', ALLOWSTART='$IN_ALLOWSTART', BOOTSTART='$IN_BOOTSTART', AUTOCLEANUP='$IN_AUTOCLEANUP', MAILNOTIFY='$IN_MAILNOTIFY', HIPCHATNOTIFY='$IN_HIPCHATNOTIFY', MAILTO='$IN_MAILTO', STARTBIN='$IN_STARTBIN', STARTBINARGS='$IN_STARTBINARGS', RECOVER_CRASH_ENABLE='$IN_RECOVER_CRASH_ENABLE', RECOVER_WATCHDOG_ENABLE='$IN_RECOVER_WATCHDOG_ENABLE', RECOVER_WATCHDOG_TEST_INTERVAL='$IN_RECOVER_WATCHDOG_TEST_INTERVAL', RECOVER_WATCHDOG_POLL_MAX='$IN_RECOVER_WATCHDOG_POLL_MAX', RECOVER_WATCHDOG_START_WAIT='$IN_RECOVER_WATCHDOG_START_WAIT', RECOVER_SLEEP='$IN_RECOVER_SLEEP', INSTVER='$IN_INSTVER', INSTVER_METHOD='$IN_INSTVER_METHOD' where INSTALLID='$IN_INSTALLID';"
		X_RECONFIGINST=$?
		if [[ ! "$X_RECONFIGINST" == 0 ]] ; then
			echoerr ""
			echoerr "ERROR: The database command returned exit code $X_RECONFIGINST."
			echoerr "  Something went wrong when attempting to record the new values."
			echoerr ""
			return 1
		else
			echo "Done"
		fi
	fi
}

f_installnewlinked() {
	# Create a new linked/child installation.
	#
	local X_CONFIGINSTALL X_INSTALLMKDIR
	#
	# We must have a master installation of the same GAMETYPE which can be used. Otherwise, it must be installed.
	if [[ -z "$USEMASTER" ]] ; then
		echo ""
		echo "No master installation for game type \"$IN_INSTALLGAMETYPE\" found in the database, so we will install one."
		f_installnewmaster
		if [[ "$NEWMASTERFAIL" == 1 ]] ; then
			echoerr ""
			echoerr "ERROR: The new master installation process failed. We can not proceed."
			echoerr ""
			return 1
		fi
	fi
	# Verify that the master installation directory exists, and err out if there is a problem.
	if [[ ! -d "$APPDIR/$USEMASTER" ]] ; then
		echoerr ""
		echoerr "ERROR: Master installation \"$USEMASTER\" found in the database, but no directory found at \"$APPDIR/$USEMASTER\"."
		echoerr "  If you uninstall the old master, a new one will automatically be installed if you try again."
		echoerr ""
		return 1
	fi
	echo "Choose a unique name/name-suffix name for the installation."
	f_choosename
	#
	# FIXME: Need an automated method of selecting IP and ports from the DB
	#
	# echo "We will now need to provide the configuration to use for this srcds installation."
	#
	# f_configinstall prompts the user for configuration input and inserts the new install into the database.
	f_configinstall ; X_CONFIGINSTALL=$?
	if [[ ! "$X_CONFIGINSTALL" == 0 ]] ; then return 1 ; fi
	#
	# Load the inst table after we have written it, since other parameters get set at the same time.
	# This is redundant, but it is also an error check, since failing here will quit the install process.
	IN_INSTALLID="$IN_INSTALLNAME"
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	#
	#
	echo ""
	echo -n "Creating new installation directory: "
	mkdir $APPDIR/$IN_INSTALLNAME ; X_INSTALLMKDIR=$?
	if [[ ! "$X_INSTALLMKDIR" == 0 ]] ; then
		echoerr ""
		echoerr "ERROR: Unable to mkdir $APPDIR/IN_INSTALLNAME, exit code $X_INSTALLMKDIR"
		echoerr ""
		return 1
	fi
	echo "Done"
	#
	# Link up the new installation to it's master.
	f_relink
	#
	# If the replay system is enabled globally, set up the directories for this server, even if won't use it.
	if [[ "$REPLAY_ENABLED" == 1 ]] && [[ -d "$REPLAYBASEDIR" ]] ; then
		echo -n "Creating public replay web dir for \"$IN_INSTALLNAME\" at \"$REPLAYDIR\": "
		mkdir -p "$REPLAYDIR"
		chmod -R 0775 "$REPLAYBASEDIR/$IN_INSTALLNAME"
		echo "Done"
	fi
	#
	echo ""
	echo "Linked installation completed."
	echo ""
	echo "Remember to add your custom configuration (autoexec.cfg, server.cfg, -exec, et-cetera). Your installation won't run properly without it."
	echo ""
	return 0
}

f_installnewmaster() {
	# Install a new master srcds installation.
	# This assumes that the srcinfo table row exists for this game type.
	# The GAMETYPE can be read in as IN_INSTALLGAMETYPE.
	# We should have gotten here via f_installnewlinked, so go read that for reference.
	#
	local X_INSTALLMASTERGETINFO X_NEWMASTERDBINSERT X_UPDATE_MAIN
	local NEWMASTER_INSTALLID NEWMASTER_GAMETYPE NEWMASTER_GAMENAME NEWMASTER_UPDATER NEWMASTER_HLDSID NEWMASTER_SERVER_APPID
	#
	echo ""
	# Get the info we need from the srcinfo database.
	while IFS='|' read GAMETYPE GAMENAME UPDATER HLDSID SERVER_APPID ; do
		echo -n "Reading database info for game type \"$IN_INSTALLGAMETYPE\": "
		NEWMASTER_GAMETYPE=$GAMETYPE
		NEWMASTER_GAMENAME=$GAMENAME
		NEWMASTER_UPDATER=$UPDATER
		NEWMASTER_HLDSID=$HLDSID
		NEWMASTER_SERVER_APPID=$SERVER_APPID
	done < <($SQLCMD "select GAMETYPE,GAMENAME,UPDATER,HLDSID,SERVER_APPID from srcinfo where GAMETYPE='$IN_INSTALLGAMETYPE';")
	X_INSTALLMASTERGETINFO=$?
	echo "Done"
	if [[ ! "$X_INSTALLMASTERGETINFO" == 0 ]] ; then
		NEWMASTERFAIL=1
		echoerr ""
		echoerr "ERROR: The database command returned exit code $X_INSTALLMASTERGETINFO."
		echoerr "  Unable to retrieve necessary information."
		echoerr ""
		return 1
	fi
	NEWMASTER_INSTALLID="${NEWMASTER_GAMETYPE}-MASTER"
	echo ""
	( echo "  Game Type:|$NEWMASTER_GAMETYPE"
	echo "  Game Name:|$NEWMASTER_GAMENAME"
	echo "  Updater:|$NEWMASTER_UPDATER"
	echo "  SteamCMD APPID:|$NEWMASTER_SERVER_APPID"
	echo "  New master name:|$NEWMASTER_INSTALLID"
	echo "  New directory path:|$APPDIR/$NEWMASTER_INSTALLID"
	) | column -t -s "|"
	echo ""
	echo "Proceed with new master installation?"
	read -e -r -p "y/N: " -i "" IN_INSTALLNEWMASTER_CONFIRM
	if [[ ! "$IN_INSTALLNEWMASTER_CONFIRM" == [yY] ]]; then
		NEWMASTERFAIL=1
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	#
	# Insert the new inst table record. A number of fields get set null/empty/sane specifically for master installations.
	echo -n "Registering the master installation into the database: "
	$SQLCMD "insert into 'inst' (INSTALLID, GAMETYPE, INSTTYPE, IPADDR, CLIENTPORT, HOSTPORT, TVPORT, STEAMPORT, ALLOWUPDATE, ALLOWSTART, BOOTSTART, AUTOCLEANUP, MAILNOTIFY, HIPCHATNOTIFY, MAILTO, STARTBIN, STARTBINARGS, INSTVER, INSTVER_METHOD) values ('$NEWMASTER_INSTALLID', '$NEWMASTER_GAMETYPE', 'master', '', '', '', '', '', '1', '0', '0', '0', '', '', '', '', '', '0', 'db' );"
	X_NEWMASTERDBINSERT=$?
	echo "Done"
	if [[ ! "$X_NEWMASTERDBINSERT" == 0 ]] ; then
		NEWMASTERFAIL=1
		echoerr ""
		echoerr "ERROR: The database command returned exit code $X_NEWMASTERDBINSERT."
		echoerr "  We can not proceed since we don't know if the insert was recorded correctly."
		echoerr ""
		return 1
	fi
	#
	# Make the new installation directory.
	mkdir "$APPDIR/$NEWMASTER_INSTALLID" ; X_NEWMASTER_MKDIR=$?
	if [[ ! "$X_NEWMASTER_MKDIR" == 0 ]] ; then
		NEWMASTERFAIL=1
		echoerr ""
		echoerr "ERROR: There was a problem creating the new master installation directory."
		echoerr "  Exit code: $X_NEWMASTER_MKDIR, installation directory: \"$APPDIR/NEWMASTER_INSTALLID\"."
		echoerr ""
		return 1
	fi
	#
	# Once we have the DB entry and installation directory, we just update it since there is little difference between a new install and an update.
	IN_INSTALLID="$NEWMASTER_INSTALLID"
	f_update ; X_UPDATE_MAIN="$?"
	if [[ ! "$X_UPDATE_MAIN" == 0 ]] ; then
		NEWMASTERFAIL=1
		return 1
	fi
	#
	echo ""
	echo "Master install completed."
	echo ""
}

f_changegametype() {
	# FIXME: this needs lots of review. 
	#
	# FIXME: Need to validate input. For example, GAMENAME "Garry's Mod" blows up the SQLite insert command.
	#
	# Configure a game type. We may be installing a new game type for a newinstall, or reconfiguring an existing one.
	#
	local X_INSTALLDBGAMETYPE X_CHANGEGAMETYPE
	#
	# If configuring as new, then use supplied defaults.
	# If configuring as a reconfig, then use the existing info from the DB.
	#
	if [[ "$GAMETYPE_ARG" == "add" ]] ; then
		echo ""
		echo "In order to configure a new game type, you must register the necessary information into the database."
		echo "If you don't have the information necessary to complete the process, ctrl+c at any time to quit."
		#
		# We will need to specify defaults for each field.
		DEFAULT_GAMETYPE=""
		DEFAULT_GAMENAME=""
		DEFAULT_UPDATER="SteamCMD"
		DEFAULT_HLDSID=""
		DEFAULT_SERVER_APPID=""
		DEFAULT_CLIENT_APPID=""
		DEFAULT_GAMEARG=""
		DEFAULT_BINDIRSUBD=""
		DEFAULT_STEAMINF=""
		DEFAULT_INSTDEF_ALLOWUPDATE="1"
		DEFAULT_INSTDEF_ALLOWSTART="1"
		DEFAULT_INSTDEF_BOOTSTART="1"
		DEFAULT_INSTDEF_AUTOCLEANUP="1"
		DEFAULT_INSTDEF_MAILNOTIFY="1"
		DEFAULT_INSTDEF_HIPCHATNOTIFY="1"
		DEFAULT_INSTDEF_MAILTO=""
		DEFAULT_INSTDEF_RECOVER_CRASH_ENABLE="1"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_ENABLE="1"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL="10"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_POLL_MAX="6"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_START_WAIT="60"
		DEFAULT_INSTDEF_RECOVER_SLEEP="10"
		DEFAULT_INSTDEF_IPADDR="0.0.0.0"
		DEFAULT_INSTDEF_HOSTPORT="27015"
		DEFAULT_INSTDEF_CLIENTPORT="$[DEFAULT_INSTDEF_HOSTPORT+1]"
		DEFAULT_INSTDEF_TVPORT="$[DEFAULT_INSTDEF_HOSTPORT+2]"
		DEFAULT_INSTDEF_STEAMPORT="$[DEFAULT_INSTDEF_HOSTPORT+3]"
		DEFAULT_INSTDEF_STARTBIN="$MYNAME"
		DEFAULT_INSTDEF_STARTBINARGS='-game $GAMEARG -ip $IPADDR +clientport $CLIENTPORT +hostport $HOSTPORT +tv_port $TVPORT -steamport $STEAMPORT -pidfile $PIDFILE -strictportbind'
	elif [[ "$GAMETYPE_ARG" == "change" ]] ; then
		# We should load the existing parameters from the database.
		echo ""
		echo "This process will help you reconfigure an existing gametype configuration."
		echo ""
		echo "Please choose a srcds game type from the list below: "
		echo ""
		( echo "  Game Type|Game Name"
		echo "  --|--"
		while IFS='|' read GAMETYPE GAMENAME ; do
				echo "  $GAMETYPE|$GAMENAME"
		done < <($SQLCMD "select GAMETYPE,GAMENAME from srcinfo;")
		) | column -t -s "|"
		echo ""
		GAMETYPE_LIST=$($SQLCMD "select GAMETYPE from srcinfo;")
		select IN_SELECTGAMETYPE in $GAMETYPE_LIST ; do
			IN_GAMETYPE="$IN_SELECTGAMETYPE"
			f_loaddbsrcinfo
			break
		done
		#
		if [[ "$LOADDBSRCINFO_FAIL" == 1 ]] ; then
			echoerr ""
			echoerr "ERROR: Unable to get the current configuration from the database."
			echoerr ""
			return 1
		fi
		DEFAULT_GAMETYPE="$GAMETYPE"
		DEFAULT_GAMENAME="$GAMENAME"
		DEFAULT_UPDATER="$UPDATER"
		DEFAULT_HLDSID="$HLDSID"
		DEFAULT_SERVER_APPID="$SERVER_APPID"
		DEFAULT_CLIENT_APPID="$CLIENT_APPID"
		DEFAULT_GAMEARG="$GAMEARG"
		DEFAULT_BINDIRSUBD="$BINDIRSUBD"
		DEFAULT_STEAMINF="$STEAMINF"
		DEFAULT_INSTDEF_ALLOWUPDATE="$INSTDEF_ALLOWUPDATE"
		DEFAULT_INSTDEF_ALLOWSTART="$INSTDEF_ALLOWSTART"
		DEFAULT_INSTDEF_BOOTSTART="$INSTDEF_BOOTSTART"
		DEFAULT_INSTDEF_AUTOCLEANUP="$INSTDEF_AUTOCLEANUP"
		DEFAULT_INSTDEF_MAILNOTIFY="$INSTDEF_MAILNOTIFY"
		DEFAULT_INSTDEF_HIPCHATNOTIFY="$INSTDEF_HIPCHATNOTIFY"
		DEFAULT_INSTDEF_MAILTO="$MAILTO"
		DEFAULT_INSTDEF_RECOVER_CRASH_ENABLE="$INSTDEF_RECOVER_CRASH_ENABLE"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_ENABLE="$INSTDEF_RECOVER_WATCHDOG_ENABLE"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL="$INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_POLL_MAX="$INSTDEF_RECOVER_WATCHDOG_POLL_MAX"
		DEFAULT_INSTDEF_RECOVER_WATCHDOG_START_WAIT="$INSTDEF_RECOVER_WATCHDOG_START_WAIT"
		DEFAULT_INSTDEF_RECOVER_SLEEP="$INSTDEF_RECOVER_SLEEP"
		DEFAULT_INSTDEF_IPADDR="$INSTDEF_IPADDR"
		DEFAULT_INSTDEF_CLIENTPORT="$INSTDEF_CLIENTPORT"
		DEFAULT_INSTDEF_HOSTPORT="$INSTDEF_HOSTPORT"
		DEFAULT_INSTDEF_TVPORT="$INSTDEF_TVPORT"
		DEFAULT_INSTDEF_STEAMPORT="$INSTDEF_STEAMPORT"
		DEFAULT_INSTDEF_STARTBIN="$INSTDEF_STARTBIN"
		DEFAULT_INSTDEF_STARTBINARGS="$INSTDEF_STARTBINARGS"

		echo ""
		echo "First, let's show the existing configuration: "
		echo ""
		$SQLSHOWCMD "select * from srcinfo where GAMETYPE='$IN_GAMETYPE';"
		echo ""
		echo "Would you like to proceed in reconfiguring this gametype?"
		read -e -r -p "y/N: " -i "" IN_RECONFIG_CONFIRM
		if [[ ! "$IN_RECONFIG_CONFIRM" == [yY] ]]; then
			echo ""
			echo "Quitting."
			echo ""
			return 0
		fi
		echo ""
		echo "Okay, let's proceed."
	fi
	# --
	echo ""
	echo "WARNING: We do not validate input here at this time."
	echo "  For example, don't use an apostrophe. The GAMENAME \"Garry's Mod\" will cause an error."
	echo "  We assume you know what you are doing. You were warned."
	echo ""
	echo "What is the Game Type name? This should be a short abbreviated name, like tf2, csgo, or l4d2."
	read -e -r -p "GAMETYPE: " -i "$DEFAULT_GAMETYPE" IN_NEW_GAMETYPE
	echo ""
	#
	echo "What is the Game Name? This should be Valve's official name for the product, like \"Team Fortress 2\"."
	read -e -r -p "GAMENAME: " -i "$DEFAULT_GAMENAME" IN_NEW_GAMENAME
	echo ""
	#
	echo "What is the Updater type? Only \"SteamCMD\" is supported, so you don't really have a choice here."
	read -e -r -p "UPDATER: " -i "$DEFAULT_UPDATER" IN_NEW_UPDATER
	echo ""
	#
	echo "What is the HLDS Game Type ID? NOTE: HLDSUpdateTool is depreciated, so this is not needed. Probably leave it blank."
	read -e -r -p "HLDSID: " -i "$DEFAULT_HLDSID" IN_NEW_HLDSID
	echo ""
	#
	echo "What is the SteamPipe Server APPID, as used in updating with SteamCMD?"
	read -e -r -p "SERVER_APPID: " -i "$DEFAULT_SERVER_APPID" IN_NEW_SERVER_APPID
	echo ""
	#
	echo "What is the SteamPipe client APPID? This is the \"appID\" in the steam.inf file."
	read -e -r -p "CLIENT_APPID: " -i "$DEFAULT_CLIENT_APPID" IN_NEW_CLIENT_APPID
	echo ""
	#
	echo "What is the Game Argument? This is passed to the \"-game\" argument in the startup command line (STARTBINARGS)."
	read -e -r -p "GAMEARG: " -i "$DEFAULT_GAMEARG" IN_NEW_GAMEARG
	echo ""
	#
	echo "What is the Binary Directory Subdirectory? This is where you will find the srcds_linux/srcds_run files."
	read -e -r -p "BINDIRSUBD: " -i "$DEFAULT_BINDIRSUBD" IN_NEW_BINDIRSUBD
	echo ""
	#
	echo "What is the steam.inf file path?"
	read -e -r -p "STEAMINF: " -i "$DEFAULT_STEAMINF" IN_NEW_STEAMINF
	echo ""
	#
	echo "What should the inst default IP Address be?"
	read -e -r -p "INSTDEF_IPADDR: " -i "$DEFAULT_INSTDEF_IPADDR" IN_NEW_INSTDEF_IPADDR
	echo ""
	#
	echo "What should the inst default Client Port be?"
	read -e -r -p "INSTDEF_CLIENTPORT: " -i "$DEFAULT_INSTDEF_CLIENTPORT" IN_NEW_INSTDEF_CLIENTPORT
	echo ""
	#
	echo "What should the inst default Host Port be?"
	read -e -r -p "INSTDEF_HOSTPORT: " -i "$DEFAULT_INSTDEF_HOSTPORT" IN_NEW_INSTDEF_HOSTPORT
	echo ""
	#
	echo "What should the inst default TV Port be?"
	read -e -r -p "INSTDEF_TVPORT: " -i "$DEFAULT_INSTDEF_TVPORT" IN_NEW_INSTDEF_TVPORT
	echo ""
	#
	echo "What should the inst default Steam Port be?"
	read -e -r -p "INSTDEF_STEAMPORT: " -i "$DEFAULT_INSTDEF_STEAMPORT" IN_NEW_INSTDEF_STEAMPORT
	echo ""
	#
	echo "What should the inst default Allow Update field be?"
	read -e -r -p "INSTDEF_ALLOWUPDATE: " -i "$DEFAULT_INSTDEF_ALLOWUPDATE" IN_NEW_INSTDEF_ALLOWUPDATE
	echo ""
	#
	echo "What should the inst default Allow Start field be?"
	read -e -r -p "INSTDEF_ALLOWSTART: " -i "$DEFAULT_INSTDEF_ALLOWSTART" IN_NEW_INSTDEF_ALLOWSTART
	echo ""
	#
	echo "What should the inst default Boot Start field be?"
	read -e -r -p "INSTDEF_BOOTSTART: " -i "$DEFAULT_INSTDEF_BOOTSTART" IN_NEW_INSTDEF_BOOTSTART
	echo ""
	#
	echo "What should the inst default Auto Cleanup field be?"
	read -e -r -p "INSTDEF_AUTOCLEANUP: " -i "$DEFAULT_INSTDEF_AUTOCLEANUP" IN_NEW_INSTDEF_AUTOCLEANUP
	echo ""
	#
	echo "What should the inst default Mail Notify field be?"
	read -e -r -p "INSTDEF_MAILNOTIFY: " -i "$DEFAULT_INSTDEF_MAILNOTIFY" IN_NEW_INSTDEF_MAILNOTIFY
	echo ""
	#
	echo "What should the inst default Hipchat Notify field be?"
	read -e -r -p "INSTDEF_HIPCHATNOTIFY: " -i "$DEFAULT_INSTDEF_HIPCHATNOTIFY" IN_NEW_INSTDEF_HIPCHATNOTIFY
	echo ""
	#
	echo "What should the inst default Mailto address be?"
	read -e -r -p "INSTDEF_MAILTO: " -i "$DEFAULT_INSTDEF_MAILTO" IN_NEW_INSTDEF_MAILTO
	echo ""
	#
	echo "What should the inst default Recovery Crash Enabled field be?"
	read -e -r -p "INSTDEF_RECOVER_CRASH_ENABLE: " -i "$DEFAULT_INSTDEF_RECOVER_CRASH_ENABLE" IN_NEW_INSTDEF_RECOVER_CRASH_ENABLE
	echo ""
	#
	echo "What should the inst default Recovery Watchdog Enabled field be?"
	read -e -r -p "INSTDEF_RECOVER_WATCHDOG_ENABLE: " -i "$DEFAULT_INSTDEF_RECOVER_WATCHDOG_ENABLE" IN_NEW_INSTDEF_RECOVER_WATCHDOG_ENABLE
	echo ""
	#
	echo "What should the inst default Recovery Watchdog Test Interval field be?"
	read -e -r -p "INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL: " -i "$DEFAULT_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL" IN_NEW_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL
	echo ""
	#
	echo "What should the inst default Recovery Watchdog Max Poll field be?"
	read -e -r -p "INSTDEF_RECOVER_WATCHDOG_POLL_MAX: " -i "$DEFAULT_INSTDEF_RECOVER_WATCHDOG_POLL_MAX" IN_NEW_INSTDEF_RECOVER_WATCHDOG_POLL_MAX
	echo ""
	#
	echo "What should the inst default Recovery Watchdog Start Wait field be?"
	read -e -r -p "INSTDEF_RECOVER_WATCHDOG_START_WAIT: " -i "$DEFAULT_INSTDEF_RECOVER_WATCHDOG_START_WAIT" IN_NEW_INSTDEF_RECOVER_WATCHDOG_START_WAIT
	echo ""
	#
	echo "What should the inst default Recovery Sleep field be?"
	read -e -r -p "INSTDEF_RECOVER_SLEEP: " -i "$DEFAULT_INSTDEF_RECOVER_SLEEP" IN_NEW_INSTDEF_RECOVER_SLEEP
	echo ""
	#
	echo "What should the inst default Startup Binary be?"
	read -e -r -p "INSTDEF_STARTBIN: " -i "$DEFAULT_INSTDEF_STARTBIN" IN_NEW_INSTDEF_STARTBIN
	echo ""
	#
	echo "What should the inst default Startup Arguments be?"
	read -e -r -p "INSTDEF_STARTBINARGS: " -i "$DEFAULT_INSTDEF_STARTBINARGS" IN_NEW_INSTDEF_STARTBINARGS
	echo ""
	#
	echo "Let's review all of the information: "
	echo ""	
	( for EACH in GAMETYPE GAMENAME UPDATER HLDSID SERVER_APPID CLIENT_APPID GAMEARG BINDIRSUBD STEAMINF INSTDEF_IPADDR INSTDEF_CLIENTPORT INSTDEF_HOSTPORT INSTDEF_TVPORT INSTDEF_STEAMPORT INSTDEF_ALLOWUPDATE INSTDEF_ALLOWSTART INSTDEF_BOOTSTART INSTDEF_AUTOCLEANUP INSTDEF_MAILNOTIFY INSTDEF_HIPCHATNOTIFY INSTDEF_MAILTO INSTDEF_RECOVER_CRASH_ENABLE INSTDEF_RECOVER_WATCHDOG_ENABLE INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL INSTDEF_RECOVER_WATCHDOG_POLL_MAX INSTDEF_RECOVER_WATCHDOG_START_WAIT INSTDEF_RECOVER_SLEEP INSTDEF_STARTBIN INSTDEF_STARTBINARGS ; do
		IN_NEW_EACH="IN_NEW_${EACH}"
		echo "  ${EACH}|:|${!IN_NEW_EACH}"
	done ; unset EACH IN_NEW_EACH
	) | column -t -s "|"
	#
	echo ""
	echo "It this correct, and would you like to proceed?"
	read -e -r -p "y/N: " -i "" IN_INSTALLNEWTYPE_CONFIRM
	if [[ ! "$IN_INSTALLNEWTYPE_CONFIRM" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	echo ""
	# If we are here for a new game type, we are going to do an SQL insert. If we are here for a change, we do an update.
	if [[ "$GAMETYPE_ARG" == "add" ]] ; then
		echo ""
		echo -n "Registering the new game type into the database: "
		$SQLCMD "insert into 'srcinfo' (GAMETYPE, GAMENAME, UPDATER, HLDSID, SERVER_APPID, CLIENT_APPID, GAMEARG, BINDIRSUBD, STEAMINF, INSTDEF_IPADDR, INSTDEF_CLIENTPORT, INSTDEF_HOSTPORT, INSTDEF_TVPORT, INSTDEF_STEAMPORT, INSTDEF_ALLOWUPDATE, INSTDEF_ALLOWSTART, INSTDEF_BOOTSTART, INSTDEF_AUTOCLEANUP, INSTDEF_MAILNOTIFY, INSTDEF_HIPCHATNOTIFY, INSTDEF_MAILTO, INSTDEF_RECOVER_CRASH_ENABLE, INSTDEF_RECOVER_WATCHDOG_ENABLE, INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL, INSTDEF_RECOVER_WATCHDOG_POLL_MAX, INSTDEF_RECOVER_WATCHDOG_START_WAIT, INSTDEF_RECOVER_SLEEP, INSTDEF_STARTBIN, INSTDEF_STARTBINARGS) values ('$IN_NEW_GAMETYPE', '$IN_NEW_GAMENAME', '$IN_NEW_UPDATER', '$IN_NEW_HLDSID', '$IN_NEW_SERVER_APPID', '$IN_NEW_CLIENT_APPID', '$IN_NEW_GAMEARG', '$IN_NEW_BINDIRSUBD', '$IN_NEW_STEAMINF', '$IN_NEW_INSTDEF_IPADDR', '$IN_NEW_INSTDEF_CLIENTPORT', '$IN_NEW_INSTDEF_HOSTPORT', '$IN_NEW_INSTDEF_TVPORT', '$IN_NEW_INSTDEF_STEAMPORT', '$IN_NEW_INSTDEF_ALLOWUPDATE', '$IN_NEW_INSTDEF_ALLOWSTART', '$IN_NEW_INSTDEF_BOOTSTART', '$IN_NEW_INSTDEF_AUTOCLEANUP', '$IN_NEW_INSTDEF_MAILNOTIFY', '$IN_NEW_INSTDEF_HIPCHATNOTIFY', '$IN_NEW_INSTDEF_MAILTO', '$IN_NEW_INSTDEF_RECOVER_CRASH_ENABLE', '$IN_NEW_INSTDEF_RECOVER_WATCHDOG_ENABLE', '$IN_NEW_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL', '$IN_NEW_INSTDEF_RECOVER_WATCHDOG_POLL_MAX', '$IN_NEW_INSTDEF_RECOVER_WATCHDOG_START_WAIT', '$IN_NEW_INSTDEF_RECOVER_SLEEP', '$IN_NEW_INSTDEF_STARTBIN', '$IN_NEW_INSTDEF_STARTBINARGS');"
		X_INSTALLDBGAMETYPE=$?
		if [[ ! "$X_INSTALLDBGAMETYPE" == 0 ]] ; then
			echoerr ""
			echoerr "ERROR: The database command returned exit code $X_INSTALLDBGAMETYPE."
			echoerr "  Something went wrong when attempting to record the new installation."
			echoerr ""
			return 1
		else
			echo "Done"
		fi
	elif [[ "$GAMETYPE_ARG" == "change" ]] ; then
		echo -n "Registering the game type changed config into the database: "
		$SQLCMD "update srcinfo set GAMETYPE='$IN_NEW_GAMETYPE', GAMENAME='$IN_NEW_GAMENAME', UPDATER='$IN_NEW_UPDATER', HLDSID='$IN_NEW_HLDSID', SERVER_APPID='$IN_NEW_SERVER_APPID', CLIENT_APPID='$IN_NEW_CLIENT_APPID', GAMEARG='$IN_NEW_GAMEARG', BINDIRSUBD='$IN_NEW_BINDIRSUBD', STEAMINF='$IN_NEW_STEAMINF', INSTDEF_IPADDR='$IN_NEW_INSTDEF_IPADDR', INSTDEF_CLIENTPORT='$IN_NEW_INSTDEF_CLIENTPORT', INSTDEF_HOSTPORT='$IN_NEW_INSTDEF_HOSTPORT', INSTDEF_TVPORT='$IN_NEW_INSTDEF_TVPORT', INSTDEF_STEAMPORT='$IN_NEW_INSTDEF_STEAMPORT', INSTDEF_ALLOWUPDATE='$IN_NEW_INSTDEF_ALLOWUPDATE', INSTDEF_ALLOWSTART='$IN_NEW_INSTDEF_ALLOWSTART', INSTDEF_BOOTSTART='$IN_NEW_INSTDEF_BOOTSTART', INSTDEF_AUTOCLEANUP='$IN_NEW_INSTDEF_AUTOCLEANUP', INSTDEF_MAILNOTIFY='$IN_NEW_INSTDEF_MAILNOTIFY', INSTDEF_HIPCHATNOTIFY='$IN_NEW_INSTDEF_HIPCHATNOTIFY', INSTDEF_MAILTO='$IN_NEW_INSTDEF_MAILTO', INSTDEF_RECOVER_CRASH_ENABLE='$IN_NEW_INSTDEF_RECOVER_CRASH_ENABLE', INSTDEF_RECOVER_WATCHDOG_ENABLE='$IN_NEW_INSTDEF_RECOVER_WATCHDOG_ENABLE', INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL='$IN_NEW_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL', INSTDEF_RECOVER_WATCHDOG_POLL_MAX='$IN_NEW_INSTDEF_RECOVER_WATCHDOG_POLL_MAX', INSTDEF_RECOVER_WATCHDOG_START_WAIT='$IN_NEW_INSTDEF_RECOVER_WATCHDOG_START_WAIT', INSTDEF_RECOVER_SLEEP='$IN_NEW_INSTDEF_RECOVER_SLEEP', INSTDEF_STARTBIN='$IN_NEW_INSTDEF_STARTBIN', INSTDEF_STARTBINARGS='$IN_NEW_INSTDEF_STARTBINARGS' where GAMETYPE='$IN_GAMETYPE';"
		X_CHANGEGAMETYPE=$?
		if [[ ! "$X_CHANGEGAMETYPE" == 0 ]] ; then
			echoerr ""
			echoerr "ERROR: The database command returned exit code $X_CHANGEGAMETYPE."
			echoerr "  Something went wrong when attempting to record the new values."
			echoerr ""
			return 1
		else
			echo "Done"
		fi
	fi
	echo ""
	echo "The game type has been successfully recorded."
	echo ""
}

f_install() {
	# Install a new srcds installation.
	#
	local GAMETYPE_LIST X_NEWINSTALL_NEWTYPE
	#
	# Ignore the IN_INSTALLID, if it was provided as an argument. FIXME: This should not be possible since 'install' became a IN_PARAMS1.
	if [[ -n "$IN_INSTALLID" ]] ; then
		IN_INSTALLID=""
	fi
	echo ""
	echo "This process will assist you in installing a new srcds installation."
	echo ""
	echo "You will need to provide information about the new installation, including:"
	echo "	A unique name for the installation."
	echo "	The srcds game type."
	echo "	The IP address and service ports."
	echo ""
	while true ; do
		echo "Please choose a srcds game type from the list below: "
		echo ""
		( echo "  Game Type|Game Name"
		echo "  --|--"
		while IFS='|' read GAMETYPE GAMENAME ; do
			echo "  $GAMETYPE|$GAMENAME"
		done < <($SQLCMD "select GAMETYPE,GAMENAME from srcinfo;")
		) | column -t -s "|"
		echo ""
		echo "To install a new srcds game type, choose \"NEW\"."
		echo "To quit, choose \"QUIT\"."
		echo ""
		GAMETYPE_LIST=$($SQLCMD "select GAMETYPE from srcinfo;")
		select IN_INSTALLGAMETYPE in $GAMETYPE_LIST NEW QUIT ; do
			case "$IN_INSTALLGAMETYPE" in
				'QUIT')
					echo ""
					echo "Quitting."
					echo ""
					return 0
				;;
				'NEW')
					GAMETYPE_ARG="add"
					f_changegametype ; X_NEWINSTALL_NEWTYPE="$?"
					if [[ "$X_NEWINSTALL_NEWTYPE" == 0 ]] ; then
						echo "We will now restart the installation process and the new game type should be available for selection."
						echo ""
					else
						echoerr "Installing the new game type failed. Unable to continue."
						echoerr ""
						return "$X_NEWINSTALL_NEWTYPE"
					fi
					break
				;;
				*)
					# Validate it.
					if [[ -z "$IN_INSTALLGAMETYPE" ]] ; then
						echo "Choose the number which corresponds with the game type which you wish to install."
					else
						IN_GAMETYPE=$IN_INSTALLGAMETYPE
						f_loaddbsrcinfo
						if [[ "$LOADDBSRCINFO_FAIL" == 1 ]] ; then exit 1 ; fi
						f_installnewlinked
						return "$?"
					fi
			esac
		done
	done
}

f_tmuxattach() {
	# Attach to the tmux session for a given installation.
	#
	local X_TMUXATTACH
	#
	# FIXME: Need to call f_getpid here and give feedback based on status.
	# FIXME: current stdout is bad.
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	# If we didn't get a valid INSTALLID, fail.
	if [[ -z "$INSTALLID" ]] ; then
		return 1
	fi
	echo ""
	echo "Attaching to tmux session $INSTALLID: "
	tmux attach-session -t "$INSTALLID" ; X_TMUXATTACH=$?
	echo ""
	return 0
}

f_listbootstartable() {
	# Get a list of srcds installations which should be started at host boot and place them into LIST_BOOTSTARTABLE.
	#
	LIST_BOOTSTARTABLE=$($SQLCMD "select INSTALLID from inst where BOOTSTART='1' and not INSTTYPE='master';")
}

f_listrunnable() {
	# Get a list of possibly runnable srcds installations and place them into LIST_RUNNABLE.
	#
	LIST_RUNNABLE=$($SQLCMD "select INSTALLID from inst where INSTTYPE='linked' or INSTTYPE='standalone';")
	# LIST_RUNNABLE=$($SQLCMD "select INSTALLID from inst where ALLOWSTART='1' and not INSTTYPE='master';")
}

f_listrunning() {
	# Get a list of actively running srcds installation and place them into a list; LIST_RUNNING
	#
	f_listrunnable
	#
	# Look for the PID file in all runnable servers to get the list of actively running.
	for EACH in $LIST_RUNNABLE ; do
		# FIXME: Need to use RUNSTATUS here instead.
		# echoerr "DEBUG: EACH=$EACH"
		# echoerr "DEBUG: PIDFILE=$PIDFILE"
		PIDFILE=$APPDIR/$EACH/server.pid
		if [[ -f "$PIDFILE" ]] ; then
			if [[ -z "$LIST_RUNNING" ]] ; then
				LIST_RUNNING="$EACH"
			else
				LIST_RUNNING="$LIST_RUNNING $EACH"
			fi
		else
			continue
		fi
	done ; unset EACH PIDFILE
}

f_loaddbsrcinfo() {
	# Load the database config for a particular game type.
	#
	unset LOADDBSRCINFO_FAIL
	unset BINDIRSUBD CLIENT_APPID DB_BINDIRSUBD DB_CLIENT_APPID DB_GAMEARG DB_GAMENAME DB_GAMETYPE DB_HLDSID DB_INSTDEF_ALLOWSTART DB_INSTDEF_ALLOWUPDATE DB_INSTDEF_AUTOCLEANUP DB_INSTDEF_BOOTSTART DB_INSTDEF_CLIENTPORT DB_INSTDEF_HOSTPORT DB_INSTDEF_IPADDR DB_INSTDEF_MAILNOTIFY DB_INSTDEF_MAILTO DB_INSTDEF_RECOVER_CRASH_ENABLE DB_INSTDEF_RECOVER_SLEEP DB_INSTDEF_RECOVER_WATCHDOG_ENABLE DB_INSTDEF_RECOVER_WATCHDOG_POLL_MAX DB_INSTDEF_RECOVER_WATCHDOG_START_WAIT DB_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL DB_INSTDEF_STARTBIN DB_INSTDEF_STARTBINARGS DB_INSTDEF_STEAMPORT DB_INSTDEF_TVPORT DB_SERVER_APPID DB_STEAMINF DB_UPDATER GAMEARG GAMENAME GAMETYPE HLDSID INSTDEF_ALLOWSTART INSTDEF_ALLOWUPDATE INSTDEF_AUTOCLEANUP INSTDEF_BOOTSTART INSTDEF_CLIENTPORT INSTDEF_HOSTPORT INSTDEF_IPADDR INSTDEF_MAILNOTIFY INSTDEF_MAILTO INSTDEF_RECOVER_CRASH_ENABLE INSTDEF_RECOVER_SLEEP INSTDEF_RECOVER_WATCHDOG_ENABLE INSTDEF_RECOVER_WATCHDOG_POLL_MAX INSTDEF_RECOVER_WATCHDOG_START_WAIT INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL INSTDEF_STARTBIN INSTDEF_STARTBINARGS INSTDEF_STEAMPORT INSTDEF_TVPORT SERVER_APPID STEAMINF UPDATER USEMASTER
	local X_DBLOADCFG_SRCINFO
	#
	# echoerr "DEBUG: Loaded src DB for $IN_GAMETYPE"
	#
	# We must have a target srcinfo row to work with.
	if [[ -z "$IN_GAMETYPE" ]] ; then
		LOADDBSRCINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: Request to load game type (srcinfo) config, but no valid input."
		echoerr ""
		return 1
	fi
	# Get the srcinfo row for the game type in question.
	while IFS='|' read GAMETYPE GAMENAME GAMEARG UPDATER HLDSID SERVER_APPID CLIENT_APPID BINDIRSUBD STEAMINF INSTDEF_ALLOWUPDATE INSTDEF_ALLOWSTART INSTDEF_BOOTSTART INSTDEF_AUTOCLEANUP INSTDEF_MAILNOTIFY INSTDEF_HIPCHATNOTIFY INSTDEF_MAILTO INSTDEF_STARTBIN INSTDEF_STARTBINARGS INSTDEF_IPADDR INSTDEF_CLIENTPORT INSTDEF_HOSTPORT INSTDEF_TVPORT INSTDEF_STEAMPORT INSTDEF_RECOVER_CRASH_ENABLE INSTDEF_RECOVER_WATCHDOG_ENABLE INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL INSTDEF_RECOVER_WATCHDOG_POLL_MAX INSTDEF_RECOVER_WATCHDOG_START_WAIT INSTDEF_RECOVER_SLEEP ; do
		DB_GAMETYPE=$GAMETYPE
		DB_GAMENAME=$GAMENAME
		DB_GAMEARG=$GAMEARG
		DB_UPDATER=$UPDATER
		DB_HLDSID=$HLDSID
		DB_SERVER_APPID=$SERVER_APPID
		DB_CLIENT_APPID=$CLIENT_APPID
		DB_BINDIRSUBD=$BINDIRSUBD
		DB_STEAMINF=$STEAMINF
		DB_INSTDEF_ALLOWUPDATE="$INSTDEF_ALLOWUPDATE"
		DB_INSTDEF_ALLOWSTART="$INSTDEF_ALLOWSTART"
		DB_INSTDEF_BOOTSTART="$INSTDEF_BOOTSTART"
		DB_INSTDEF_AUTOCLEANUP="$INSTDEF_AUTOCLEANUP"
		DB_INSTDEF_MAILNOTIFY="$INSTDEF_MAILNOTIFY"
		DB_INSTDEF_HIPCHATNOTIFY="$INSTDEF_HIPCHATNOTIFY"
		DB_INSTDEF_MAILTO="$INSTDEF_MAILTO"
		DB_INSTDEF_STARTBIN="$INSTDEF_STARTBIN"
		DB_INSTDEF_STARTBINARGS="$INSTDEF_STARTBINARGS"
		DB_INSTDEF_IPADDR="$INSTDEF_IPADDR"
		DB_INSTDEF_CLIENTPORT="$INSTDEF_CLIENTPORT"
		DB_INSTDEF_HOSTPORT="$INSTDEF_HOSTPORT"
		DB_INSTDEF_TVPORT="$INSTDEF_TVPORT"
		DB_INSTDEF_STEAMPORT="$INSTDEF_STEAMPORT"
		DB_INSTDEF_RECOVER_CRASH_ENABLE="$INSTDEF_RECOVER_CRASH_ENABLE"
		DB_INSTDEF_RECOVER_WATCHDOG_ENABLE="$INSTDEF_RECOVER_WATCHDOG_ENABLE"
		DB_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL="$INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL"
		DB_INSTDEF_RECOVER_WATCHDOG_POLL_MAX="$INSTDEF_RECOVER_WATCHDOG_POLL_MAX"
		DB_INSTDEF_RECOVER_WATCHDOG_START_WAIT="$INSTDEF_RECOVER_WATCHDOG_START_WAIT"
		DB_INSTDEF_RECOVER_SLEEP="$INSTDEF_RECOVER_SLEEP"
	done < <($SQLCMD "select GAMETYPE,GAMENAME,GAMEARG,UPDATER,HLDSID,SERVER_APPID,CLIENT_APPID,BINDIRSUBD,STEAMINF,INSTDEF_ALLOWUPDATE,INSTDEF_ALLOWSTART,INSTDEF_BOOTSTART,INSTDEF_AUTOCLEANUP,INSTDEF_MAILNOTIFY,INSTDEF_HIPCHATNOTIFY,INSTDEF_MAILTO,INSTDEF_STARTBIN,INSTDEF_STARTBINARGS,INSTDEF_IPADDR,INSTDEF_CLIENTPORT,INSTDEF_HOSTPORT,INSTDEF_TVPORT,INSTDEF_STEAMPORT,INSTDEF_RECOVER_CRASH_ENABLE,INSTDEF_RECOVER_WATCHDOG_ENABLE,INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL,INSTDEF_RECOVER_WATCHDOG_POLL_MAX,INSTDEF_RECOVER_WATCHDOG_START_WAIT,INSTDEF_RECOVER_SLEEP from srcinfo where GAMETYPE='$IN_GAMETYPE';")
	X_DBLOADCFG_SRCINFO=$?
	if [[ ! "$X_DBLOADCFG_SRCINFO" == 0 ]] ; then
		LOADDBSRCINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: The database command returned exit code $X_DBLOADCFG_SRCINFO."
		echoerr "  Unable to retrieve necessary information."
		echoerr ""
		return 1
	fi
	# Verify some of the information from the database.
	# echoerr "DEBUG: IN_GAMETYPE=$IN_GAMETYPE, GAMETYPE=$GAMETYPE, DB_GAMETYPE=$DB_GAMETYPE"
	if [[ ! "$IN_GAMETYPE" == "$DB_GAMETYPE" ]] ; then
		LOADDBSRCINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: No such game type found, or the database record could not be loaded."
		echoerr ""
		return 1
	fi
	# Normalize database parameters.
		GAMETYPE=$DB_GAMETYPE
		GAMENAME=$DB_GAMENAME
		GAMEARG=$DB_GAMEARG
		UPDATER=$DB_UPDATER
		HLDSID=$DB_HLDSID
		SERVER_APPID=$DB_SERVER_APPID
		CLIENT_APPID=$DB_CLIENT_APPID
		BINDIRSUBD=$DB_BINDIRSUBD
		STEAMINF=$DB_STEAMINF
		INSTDEF_ALLOWUPDATE=$DB_INSTDEF_ALLOWUPDATE
		INSTDEF_ALLOWSTART=$DB_INSTDEF_ALLOWSTART
		INSTDEF_BOOTSTART=$DB_INSTDEF_BOOTSTART
		INSTDEF_AUTOCLEANUP=$DB_INSTDEF_AUTOCLEANUP
		INSTDEF_MAILNOTIFY=$DB_INSTDEF_MAILNOTIFY
		INSTDEF_HIPCHATNOTIFY=$DB_INSTDEF_HIPCHATNOTIFY
		INSTDEF_MAILTO=$DB_INSTDEF_MAILTO
		INSTDEF_STARTBIN=$DB_INSTDEF_STARTBIN
		INSTDEF_STARTBINARGS=$DB_INSTDEF_STARTBINARGS
		INSTDEF_IPADDR=$DB_INSTDEF_IPADDR
		INSTDEF_CLIENTPORT=$DB_INSTDEF_CLIENTPORT
		INSTDEF_HOSTPORT=$DB_INSTDEF_HOSTPORT
		INSTDEF_TVPORT=$DB_INSTDEF_TVPORT
		INSTDEF_STEAMPORT=$DB_INSTDEF_STEAMPORT
		INSTDEF_RECOVER_CRASH_ENABLE="$DB_INSTDEF_RECOVER_CRASH_ENABLE"
		INSTDEF_RECOVER_WATCHDOG_ENABLE="$DB_INSTDEF_RECOVER_WATCHDOG_ENABLE"
		INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL="$DB_INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL"
		INSTDEF_RECOVER_WATCHDOG_POLL_MAX="$DB_INSTDEF_RECOVER_WATCHDOG_POLL_MAX"
		INSTDEF_RECOVER_WATCHDOG_START_WAIT="$DB_INSTDEF_RECOVER_WATCHDOG_START_WAIT"
		INSTDEF_RECOVER_SLEEP="$DB_INSTDEF_RECOVER_SLEEP"
	# Set the master installation, if it exists.
	USEMASTER=$($SQLCMD "select INSTALLID from inst where INSTTYPE='master' and GAMETYPE='$GAMETYPE' limit 1;")
	#
}

f_loaddbinst() {
	# Load the database config for a particular installation.
	#
	unset LOADDBINSTINFO_FAIL
	unset ALLOWSTART ALLOWUPDATE AUTOCLEANUP BINDIR BINDIRSUBD BOOTSTART CLIENT_APPID CLIENTPORT DB_ALLOWSTART DB_ALLOWUPDATE DB_AUTOCLEANUP DB_BINDIRSUBD DB_BOOTSTART DB_CLIENT_APPID DB_CLIENTPORT DB_GAMEARG DB_GAMENAME DB_GAMETYPE DB_HLDSID DB_HOSTPORT DB_INSTALLID DB_INSTDEF_ALLOWSTART DB_INSTDEF_ALLOWUPDATE DB_INSTDEF_AUTOCLEANUP DB_INSTDEF_BOOTSTART DB_INSTDEF_CLIENTPORT DB_INSTDEF_HOSTPORT DB_INSTDEF_IPADDR DB_INSTDEF_MAILNOTIFY DB_INSTDEF_MAILTO DB_INSTDEF_STARTBIN DB_INSTDEF_STARTBINARGS DB_INSTDEF_STEAMPORT DB_INSTDEF_TVPORT DB_INSTTYPE DB_INSTVER DB_INSTVER_METHOD DB_IPADDR DB_MAILNOTIFY DB_MAILTO DB_RECOVER_CRASH_ENABLE DB_RECOVER_SLEEP DB_RECOVER_WATCHDOG_ENABLE DB_RECOVER_WATCHDOG_POLL_MAX DB_RECOVER_WATCHDOG_START_WAIT DB_RECOVER_WATCHDOG_TEST_INTERVAL DB_SERVER_APPID DB_STARTBIN DB_STARTBINARGS DB_STEAMINF DB_STEAMPORT DB_TVPORT DB_UPDATER EVALTXT_STARTBINARGS GAMEARG GAMEDIR GAMENAME GAMETYPE HLDSID HOSTPORT INSTALLDIR INSTALLID INSTDEF_ALLOWSTART INSTDEF_ALLOWUPDATE INSTDEF_AUTOCLEANUP INSTDEF_BOOTSTART INSTDEF_CLIENTPORT INSTDEF_HOSTPORT INSTDEF_IPADDR INSTDEF_MAILNOTIFY INSTDEF_MAILTO INSTDEF_STARTBIN INSTDEF_STARTBINARGS INSTDEF_STEAMPORT INSTDEF_TVPORT INSTTYPE INSTVER INSTVER_METHOD IPADDR LOCKFILE MAILNOTIFY MAILTO PIDFILE RECOVER_CRASH_ENABLE RECOVER_SLEEP RECOVER_WATCHDOG_ENABLE RECOVER_WATCHDOG_POLL_MAX RECOVER_WATCHDOG_START_WAIT RECOVER_WATCHDOG_TEST_INTERVAL REPLAYDIR SERVER_APPID STARTBIN STARTBINARGS STEAMINF STEAMINF_FILE STEAMPORT TVPORT UPDATER USEMASTER
	local DEFAULT_MAILTO X_DBLOADCFG_INST
	#
	# echoerr "DEBUG: Loading inst table for $IN_INSTALLID"
	# Skip if the param is "all"
	if [[ "$IN_INSTALLID" == "all" ]] ; then
		return	
	fi
	# We must have a target inst row to work with.
	if [[ -z "$IN_INSTALLID" ]] ; then
		LOADDBINSTINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: Request to load installation (inst) config, but no valid input."
		echoerr ""
		return 1
	fi
	DEFAULT_MAILTO=$WRENCH_MAILTO
	# Get the inst record for the working installation, and the srcinfo along with it via a join.
	while IFS='|' read INSTALLID GAMETYPE INSTTYPE IPADDR CLIENTPORT HOSTPORT TVPORT STEAMPORT GAMENAME GAMEARG UPDATER HLDSID SERVER_APPID CLIENT_APPID BINDIRSUBD STEAMINF ALLOWUPDATE ALLOWSTART BOOTSTART AUTOCLEANUP MAILNOTIFY HIPCHATNOTIFY MAILTO STARTBIN STARTBINARGS RECOVER_CRASH_ENABLE RECOVER_WATCHDOG_ENABLE RECOVER_WATCHDOG_TEST_INTERVAL RECOVER_WATCHDOG_POLL_MAX RECOVER_WATCHDOG_START_WAIT RECOVER_SLEEP INSTDEF_ALLOWUPDATE INSTDEF_ALLOWSTART INSTDEF_BOOTSTART INSTDEF_AUTOCLEANUP INSTDEF_MAILNOTIFY INSTDEF_HIPCHATNOTIFY INSTDEF_MAILTO INSTDEF_STARTBIN INSTDEF_STARTBINARGS INSTDEF_IPADDR INSTDEF_CLIENTPORT INSTDEF_HOSTPORT INSTDEF_TVPORT INSTDEF_STEAMPORT INSTVER INSTVER_METHOD ; do
		DB_INSTALLID=$INSTALLID
		DB_GAMETYPE=$GAMETYPE
		DB_INSTTYPE=$INSTTYPE
		DB_IPADDR=$IPADDR
		DB_CLIENTPORT=$CLIENTPORT
		DB_HOSTPORT=$HOSTPORT
		DB_TVPORT=$TVPORT
		DB_STEAMPORT=$STEAMPORT
		DB_GAMENAME=$GAMENAME
		DB_GAMEARG=$GAMEARG
		DB_UPDATER=$UPDATER
		DB_HLDSID=$HLDSID
		DB_SERVER_APPID=$SERVER_APPID
		DB_CLIENT_APPID=$CLIENT_APPID
		DB_BINDIRSUBD=$BINDIRSUBD
		DB_STEAMINF=$STEAMINF
		DB_ALLOWUPDATE=$ALLOWUPDATE
		DB_ALLOWSTART=$ALLOWSTART
		DB_BOOTSTART=$BOOTSTART
		DB_AUTOCLEANUP=$AUTOCLEANUP
		DB_MAILNOTIFY=$MAILNOTIFY
		DB_HIPCHATNOTIFY=$HIPCHATNOTIFY
		DB_MAILTO=$MAILTO
		DB_STARTBIN=$STARTBIN
		DB_STARTBINARGS="$STARTBINARGS"
		DB_RECOVER_CRASH_ENABLE="$RECOVER_CRASH_ENABLE"
		DB_RECOVER_WATCHDOG_ENABLE="$RECOVER_WATCHDOG_ENABLE"
		DB_RECOVER_WATCHDOG_TEST_INTERVAL="$RECOVER_WATCHDOG_TEST_INTERVAL"
		DB_RECOVER_WATCHDOG_POLL_MAX="$RECOVER_WATCHDOG_POLL_MAX"
		DB_RECOVER_WATCHDOG_START_WAIT="$RECOVER_WATCHDOG_START_WAIT"
		DB_RECOVER_SLEEP="$RECOVER_SLEEP"
		DB_INSTDEF_ALLOWUPDATE="$INSTDEF_ALLOWUPDATE"
		DB_INSTDEF_ALLOWSTART="$INSTDEF_ALLOWSTART"
		DB_INSTDEF_BOOTSTART="$INSTDEF_BOOTSTART"
		DB_INSTDEF_AUTOCLEANUP="$INSTDEF_AUTOCLEANUP"
		DB_INSTDEF_MAILNOTIFY="$INSTDEF_MAILNOTIFY"
		DB_INSTDEF_HIPCHATNOTIFY="$INSTDEF_HIPCHATNOTIFY"
		DB_INSTDEF_MAILTO="$INSTDEF_MAILTO"
		DB_INSTDEF_STARTBIN="$INSTDEF_STARTBIN"
		DB_INSTDEF_STARTBINARGS="$INSTDEF_STARTBINARGS"
		DB_INSTDEF_IPADDR="$INSTDEF_IPADDR"
		DB_INSTDEF_CLIENTPORT="$INSTDEF_CLIENTPORT"
		DB_INSTDEF_HOSTPORT="$INSTDEF_HOSTPORT"
		DB_INSTDEF_TVPORT="$INSTDEF_TVPORT"
		DB_INSTDEF_STEAMPORT="$INSTDEF_STEAMPORT"
		DB_INSTVER="$INSTVER"
		DB_INSTVER_METHOD="$INSTVER_METHOD"
	done < <($SQLCMD "select inst.INSTALLID,inst.GAMETYPE,inst.INSTTYPE,inst.IPADDR,inst.CLIENTPORT,inst.HOSTPORT,inst.TVPORT,inst.STEAMPORT,srcinfo.GAMENAME,srcinfo.GAMEARG,srcinfo.UPDATER,srcinfo.HLDSID,srcinfo.SERVER_APPID,srcinfo.CLIENT_APPID,srcinfo.BINDIRSUBD,srcinfo.STEAMINF,inst.ALLOWUPDATE,inst.ALLOWSTART,inst.BOOTSTART,inst.AUTOCLEANUP,inst.MAILNOTIFY,inst.HIPCHATNOTIFY,inst.MAILTO,inst.STARTBIN,inst.STARTBINARGS,inst.RECOVER_CRASH_ENABLE,inst.RECOVER_WATCHDOG_ENABLE,inst.RECOVER_WATCHDOG_TEST_INTERVAL,inst.RECOVER_WATCHDOG_POLL_MAX,inst.RECOVER_WATCHDOG_START_WAIT,inst.RECOVER_SLEEP,srcinfo.INSTDEF_ALLOWUPDATE,srcinfo.INSTDEF_ALLOWSTART,srcinfo.INSTDEF_BOOTSTART,srcinfo.INSTDEF_AUTOCLEANUP,srcinfo.INSTDEF_MAILNOTIFY,srcinfo.INSTDEF_HIPCHATNOTIFY,srcinfo.INSTDEF_MAILTO,srcinfo.INSTDEF_STARTBIN,srcinfo.INSTDEF_STARTBINARGS,srcinfo.INSTDEF_IPADDR,srcinfo.INSTDEF_CLIENTPORT,srcinfo.INSTDEF_HOSTPORT,srcinfo.INSTDEF_TVPORT,srcinfo.INSTDEF_STEAMPORT,inst.INSTVER,inst.INSTVER_METHOD from inst,srcinfo on inst.GAMETYPE=srcinfo.GAMETYPE where INSTALLID='$IN_INSTALLID';")
	X_DBLOADCFG_INST=$?
	# echoerr "DEBUG: DB inst info loaded, X_DBLOADCFG_INST=$X_DBLOADCFG_INST"
	if [[ ! "$X_DBLOADCFG_INST" == 0 ]] ; then
		LOADDBINSTINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: The database command returned exit code $X_DBLOADCFG_INST."
		echoerr "  Unable to load the inst table data."
		echoerr ""
		return 1
	fi
	# Verify some of the information from the database.
	# echoerr "DEBUG: IN_INSTALLID=$IN_INSTALLID, DB_INSTALLID=$DB_INSTALLID"
	if [[ ! "$IN_INSTALLID" == "$DB_INSTALLID" ]] ; then
		LOADDBINSTINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: No such installation found, or the database record could not be loaded."
		echoerr ""
		return 1
	fi
	# Check that a installation directory exists for the DB record, but only if we are not doing an install/uninstall.
	# FIXME: We should probably make this a soft erorr and let the calling function decide on what to do with it.
	if [[ ! -d "$APPDIR/$DB_INSTALLID" ]] && [[ ! "$IN_ARG" == "install" ]] && [[ ! "$IN_ARG" == "uninstall" ]]; then
		LOADDBINSTINFO_FAIL=1
		echoerr ""
		echoerr "ERROR: No installation directory for $DB_INSTALLID found at $APPDIR/$DB_INSTALLID"
		echoerr ""
		return 1
	fi
	# Normalize database parameters.
		INSTALLID=$DB_INSTALLID
		INSTALLDIR=$APPDIR/$IN_INSTALLID # Set INSTALLDIR.
		GAMETYPE=$DB_GAMETYPE
		INSTTYPE=$DB_INSTTYPE
		IPADDR=$DB_IPADDR
		CLIENTPORT=$DB_CLIENTPORT
		HOSTPORT=$DB_HOSTPORT
		TVPORT=$DB_TVPORT
		STEAMPORT=$DB_STEAMPORT
		GAMENAME=$DB_GAMENAME
		GAMEARG=$DB_GAMEARG
		UPDATER=$DB_UPDATER
		HLDSID=$DB_HLDSID
		SERVER_APPID=$DB_SERVER_APPID
		CLIENT_APPID=$DB_CLIENT_APPID
		BINDIRSUBD=$DB_BINDIRSUBD
		STEAMINF=$DB_STEAMINF
		STEAMINF_FILE=$INSTALLDIR/$DB_STEAMINF # We need the full file path, since STEAMINF is relative.
		ALLOWUPDATE=$DB_ALLOWUPDATE
		ALLOWSTART=$DB_ALLOWSTART
		BOOTSTART=$DB_BOOTSTART
		AUTOCLEANUP=$DB_AUTOCLEANUP
		MAILNOTIFY=$DB_MAILNOTIFY
		HIPCHATNOTIFY=$DB_HIPCHATNOTIFY
		MAILTO=${DB_MAILTO:-$DEFAULT_MAILTO} # Use the default MAILTO, if the DB_MAILTO is blank.
		STARTBIN=$DB_STARTBIN
		RECOVER_CRASH_ENABLE="$DB_RECOVER_CRASH_ENABLE"
		RECOVER_WATCHDOG_ENABLE="$DB_RECOVER_WATCHDOG_ENABLE"
		RECOVER_WATCHDOG_TEST_INTERVAL="$DB_RECOVER_WATCHDOG_TEST_INTERVAL"
		RECOVER_WATCHDOG_POLL_MAX="$DB_RECOVER_WATCHDOG_POLL_MAX"
		RECOVER_WATCHDOG_START_WAIT="$DB_RECOVER_WATCHDOG_START_WAIT"
		RECOVER_SLEEP="$DB_RECOVER_SLEEP"
		INSTDEF_ALLOWUPDATE=$DB_INSTDEF_ALLOWUPDATE
		INSTDEF_ALLOWSTART=$DB_INSTDEF_ALLOWSTART
		INSTDEF_BOOTSTART=$DB_INSTDEF_BOOTSTART
		INSTDEF_AUTOCLEANUP=$DB_INSTDEF_AUTOCLEANUP
		INSTDEF_MAILNOTIFY=$DB_INSTDEF_MAILNOTIFY
		INSTDEF_HIPCHATNOTIFY=$DB_INSTDEF_HIPCHATNOTIFY
		INSTDEF_MAILTO=$DB_INSTDEF_MAILTO
		INSTDEF_STARTBIN=$DB_INSTDEF_STARTBIN
		INSTDEF_STARTBINARGS=$DB_INSTDEF_STARTBINARGS
		INSTDEF_IPADDR=$DB_INSTDEF_IPADDR
		INSTDEF_CLIENTPORT=$DB_INSTDEF_CLIENTPORT
		INSTDEF_HOSTPORT=$DB_INSTDEF_HOSTPORT
		INSTDEF_TVPORT=$DB_INSTDEF_TVPORT
		INSTDEF_STEAMPORT=$DB_INSTDEF_STEAMPORT
		INSTVER="$DB_INSTVER"
		INSTVER_METHOD="$DB_INSTVER_METHOD"
	#
	LOCKFILE=$INSTALLDIR/lockfile.lock # FIXME: What kind of lockfile is this? Beware multi-use. May need to move/fix.
	PIDFILE=$INSTALLDIR/server.pid
	# In many cases, $BINDIRSUBD is going to be null, so this prevents a double slash.
	if [[ -z "$BINDIRSUBD" ]] ; then
		BINDIR=$INSTALLDIR
	else
		BINDIR=$INSTALLDIR/$BINDIRSUBD
	fi
	if [[ "$REPLAY_ENABLED" == 1 ]] && [[ -d "$REPLAYBASEDIR" ]] ; then
		REPLAYDIR="$REPLAYBASEDIR/$INSTALLID/replay"
	else
		REPLAYDIR=""
	fi
	# GAMEDIR is the directory under which we will find the cfg, resource, addons, maps, and similar directories.
	# This directory is always named after GAMEARG, used with the -game argument on the startup command.
	GAMEDIR=$INSTALLDIR/$GAMEARG
	# Normalize database parameters
		# STARTBINARGS is saved in the SQL DB as bash code, including variables. We need to eval it to do parameter expansion.
		# This needs to be done after all other parameters/variables are set, or it won't eval correctly.
		# We filter out special bash control characters for safety reasons. Imagine if someone wrote " ; rm -rf ~" in there.
		# We could do a tr sanitation whitelist like this:	tr -c -d '[:alnum:]$ [=-=].+_~/@'
		# Or we could do a tr sanitation blacklist like this:	tr -d '[:cntrl:]`;&*!@#(){}[]|\?<>'
		# Since the whitelist is more strict, we will use that.
		DB_STARTBINARGS=$(echo "$DB_STARTBINARGS" | tr -c -d '[:alnum:]$ [=-=].+_~/@')
		EVALTXT_STARTBINARGS="$DB_STARTBINARGS"
		STARTBINARGS=$(eval echo "$DB_STARTBINARGS")
	# If this is a linked install, declare the master installation. At this time, we do not support more than one master per game type.
	if [[ "$INSTTYPE" == linked ]] ; then
		USEMASTER=$($SQLCMD "select INSTALLID from inst where INSTTYPE='master' and GAMETYPE='$GAMETYPE' limit 1;")
	fi
	#
	# Validate critical info from the DB before we proceed.
	# Note that many different functions load info, so keep this generic.
	# echoerr "DEBUG: Finished inst table load for $INSTALLID"
}

f_showconfig() {
	# Show the database configuration for a particular installation.
	# FIXME: We need a real showconfig command. This isn't sufficient.
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	echo ""
	echo "Showing database configuration for installation \"$IN_INSTALLID\": "
	echo ""
	$SQLSHOWCMD "select * from inst where INSTALLID='$IN_INSTALLID';"
	echo ""
	echo "NOTE: STARTBINARGS evaluates to: "
	echo "$STARTBINARGS"
	echo ""
	echo "Also showing game type configuration (minus INSTDEF_s) for \"$GAMETYPE\": "
	echo ""
	$SQLSHOWCMD "select * from srcinfo where GAMETYPE='$GAMETYPE';" | egrep -v "^ *INSTDEF_"
	echo ""
}

f_rename() {
	# Rename an installation.
	#
	local X_RENAMEINSTDB X_RENAMEINSTDIR
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	# Do not rename master type installations.
	if [[ "$INSTTYPE" == "master" ]] ; then
		echoerr ""
		echoerr "ERROR: Master type installations can not be renamed."
		echoerr ""
		return 1
	fi
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 ]] ; then return 1 ; fi
	#
	echo ""
	echo "This process will help you rename an existing installation."
	echo ""
	echo "To what shall \"$IN_INSTALLID\" be renamed to?"
	f_choosename
	#
	# Proceed to rename the installation.
	# 
	echo -n "Renaming the installation in the database: "
	$SQLCMD "update inst set INSTALLID='$IN_INSTALLNAME' where INSTALLID='$IN_INSTALLID';"
	X_RENAMEINSTDB=$?
	if [[ ! "$X_RENAMEINSTDB" == 0 ]] ; then
		echoerr ""
		echoerr "ERROR: The database command returned exit code $X_RECONFIGINST."
		echoerr "  Unable to rename the DB entry. Stopping here."
		echoerr ""
		return 1
	else
		echo "Done"
	fi
	echo -n "Renaming the installation directory: "
	if [[ -d "$APPDIR/$IN_INSTALLID" ]] ; then
		mv "$APPDIR/$IN_INSTALLID" "$APPDIR/$IN_INSTALLNAME" ; X_RENAMEINSTDIR=$?
		if [[ ! "$X_RENAMEINSTDB" == 0 ]] ; then
			echoerr ""
			echoerr "ERROR: Renaming the installation directory failed."
			echoerr ""
			return 1
		else
			echo "Done"
		fi
	else
		echoerr ""
		echoerr "ERROR: No installation directory found!"
		echoerr ""
		return 1
	fi
	# Rename the replay directory.
	if [[ "$REPLAY_ENABLED" == 1 ]] && [[ -d "$REPLAYBASEDIR/$IN_INSTALLID" ]] ; then
		echo -n "Renaming the replay webserver directory: "
		mv "$REPLAYBASEDIR/$IN_INSTALLID" "$REPLAYBASEDIR/$IN_INSTALLNAME"
		echo "Done"
	fi
	echo ""
	echo "We have completed the rename process. However, you should check your installation files, as they may need to be updated as well."
	echo "This is especially true of the replay configuration, which specifies the replay file directory and URL presented to clients."
	echo ""
}

f_reconfig() {
	# Configure or reconfigure a srcds installation. Data is stored in the database.
	# NOTE: Do not perform any input validation here, since we may need to reconfigure both masters and linked types.
	#
	local X_CONFIGINSTALL
	#
	f_loaddbinst
	if [[ "$LOADDBINSTINFO_FAIL" == 1 ]] ; then return 1 ; fi
	f_quitifrunning # Do not proceed if the installation is actively running.
	if [[ "$RUNQUIT" == 1 ]] ; then return 1 ; fi
	#
	echo ""
	echo "This process will help you reconfigure an existing installation's configuration."
	echo ""
	echo "First, let's show the existing configuration: "
	f_showconfig
	echo "Would you like to proceed in reconfiguring this installation?"
	read -e -r -p "y/N: " -i "" IN_RECONFIG_CONFIRM
	if [[ ! "$IN_RECONFIG_CONFIRM" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	echo ""
	echo "Okay, let's proceed."
	echo ""
	f_configinstall ; X_CONFIGINSTALL=$?
	if [[ "$X_CONFIGINSTALL" == 0 ]] ; then
		echo ""
		echo "Reconfig completed."
		echo ""
	fi
}

f_rcon() {
	# Not really rcon, just sending information to the console of the tmux session.
	f_loaddbinst
	f_getpid
	IN_ALL=${IN_PARAMS#* }
	IN_ARGS=${IN_ALL#* }
	if [[ "$RUNSTATUS" == "running" ]] ; then
		echo "Sending command '$IN_ARGS' to:"
		echo " - $INSTALLID"
		tmux send-keys -t "$INSTALLID" "$IN_ARGS" C-m
	else
		echo "Instance $INSTALLID is not running!"
	fi
}

f_setup() {
	# Do the first-time setup. Dependency checks, creating the APPDIR, loading the DB, and similar requirements.
	#
	local DEPENDENCIES SQLDB_DOWNLOAD_URL STEAMCMD_INSTALLER_URL
	local X_MKDIR_APPDIR X_VALIDATE_DB X_SQLDB_DOWNLOAD X_SQLDB_LOAD X_DB_VALIDATE_POSTDOWNLOAD X_DB_POSTDOWNLOAD_UPDATE
	#
	echo ""
	echo "This process will help you with the basic setup needed to get $MYNAME up and running."
	echo ""
	echo "If you have not already, be sure to read the ${MYNAME}_README.txt file. It contains important information."
	#
	# Dependency checks.
	echo ""
	echo "--"
	echo ""
	echo "$MYNAME requires a number of dependencies to run. We will try to verify them." 
	echo ""
	echo "VERIFICATION: Shall we continue?"
	read -e -r -p "y/N: " -i "" REPLY
	if [[ ! "$REPLY" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	#
	DEPENDENCIES="lns $QSTAT_CMD tmux sqlite3 xmlstarlet symlinks wget lsof sed awk xargs cat echo kill egrep mail mkdir chmod find cut tr ps wc ip sort uniq rm stat whoami basename date nice renice ionice pgrep pkill tee"
	for EACH in $DEPENDENCIES ; do
		DEP_TARGET=$(type -p $EACH 2> /dev/null)
		# Handle shell builtins too
		if [[ -z "$DEP_TARGET" ]] && [[ "$(type $EACH)" == "$EACH is a shell builtin" ]]; then
			DEP_TARGET="shell builtin"
		fi
		if [[ -z "$DEP_TARGET" ]] ; then
			DEP_FAIL=1
			DEP_TARGET="Not found."
			DEP_STATUS="FAILURE!"
		else
			DEP_STATUS="Success"
		fi
		echo "Checking dependency \"$EACH\": Status: $DEP_STATUS : Path: $DEP_TARGET"
	done ; unset EACH DEP_TARGET DEP_STATUS
	echo ""
	if [[ "$DEP_FAIL" == 1 ]] ; then
		echoerr "ERROR: At least one dependency check failed. You will need to fix this before you can continue."
		echoerr "  The ${MYNAME}_readme.txt file has useful information regarding fixing dependancies."
		echoerr ""
		echoerr "Quitting."
		echoerr ""
		return 1
	else
		echo "All dependencies verified successfully."
	fi
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# APPDIR check and creation.
	echo ""
	echo "--"
	echo ""
	echo "Now we will check if the configured APPDIR exists, and create it if necessary."
	echo "This is where the $MYNAME database and installation directories will reside."
	echo ""
	# Test to see if APPDIR already exists.
	if [[ -d "$APPDIR" ]] ; then
		echo "APPDIR $APPDIR already exists. This is normal if performing an upgrade or re-install."
		echo ""
		echo "VERIFICATION: Shall we continue?"
		read -e -r -p "y/N: " -i "" REPLY
		if [[ ! "$REPLY" == [yY] ]]; then
			echo ""
			echo "Quitting."
			echo ""
			return 0
		fi
	else
		echo "VERIFICATION: APPDIR not found. Shall we create it now?"
		read -e -r -p "y/N: " -i "" REPLY
		if [[ ! "$REPLY" == [yY] ]]; then
			echo ""
			echo "Quitting."
			echo ""
			return 0
		fi
		echo -n "Creating the APPDIR directory \"$APPDIR\": "
		mkdir "$APPDIR" ; X_MKDIR_APPDIR=$?
		if [[ "$X_MKDIR_APPDIR" == 0 ]] ; then
			chmod u=wrx,g-rwx,o-wrx "$APPDIR" # Set perms.
			echo "Done"
		else
			echo "Failure."
			echo ""
			echo "APPDIR creation attempt failed. This is probably because you don't have filesystem permission to do so."
			echo "  This is not unexpected if you were trying to install into /srv."
			echo "  Please manually create the directory and try setup again."
			echo ""
			return 1
		fi
	fi
	#
	# DB installation.
	echo ""
	echo "--"
	echo ""
	echo "$MYNAME requires an SQLite database to keep track of installations and game server types."
	#
	f_validate_db &> /dev/null ; X_VALIDATE_DB=$?
	if [[ "$X_VALIDATE_DB" == 0 ]] ; then
		echo ""
		echo "Existing vaid database file found: $SQLDBFILE. DB version: $DB_VER"
	elif [[ "$X_VALIDATE_DB" == 3 ]] ; then
		# If there was no DB file, we need to create one.
		echo ""
		echo "No database file found. This is normal for a new installation."
		echo ""
		echo "  Do you want download a sample DB which includes configuration for common srcds servers "
		echo "  (TF2, CSS, CSGO, L4D2, HL2DM), or do you want to start out with a new, blank, DB?"
		echo "  HINT: You probably want to download it."
		echo ""
		select DB_OPT in DOWNLOAD NEW ; do
			if [[ "$DB_OPT" == "DOWNLOAD" ]] ; then
				# Sample DB with pre-loaded game types.
				SQLDB_DOWNLOAD_URL="https://raw.githubusercontent.com/riemers/wrench/master/wrench.db" # DB file source.
				echo ""
				echo "Downloading and installing database: "
				wget --timeout=30 --tries=3 -O "$SQLDBFILE.tmp" "$SQLDB_DOWNLOAD_URL" &> /dev/null ; X_SQLDB_DOWNLOAD=$?
				if ! [[ "$X_SQLDB_DOWNLOAD" == 0 ]] ; then
					echoerr ""
					echoerr "ERROR: Unable to download sample DB file."
					echoerr "  SQL DB Download URL: $SQLDB_DOWNLOAD_URL"
					echoerr ""
					return 1
				fi
				# The downloaded DB file is actually a .dump and is loaded via import.
				$SQLITE "$SQLDBFILE" < "$SQLDBFILE.tmp" ; X_SQLDB_LOAD=$?
				if ! [[ "$X_SQLDB_LOAD" == 0 ]] ; then
					echoerr ""
					echoerr "ERROR: SQLITE exited $X_SQLDB_LOAD. Loading failed."
					echoerr ""
					return 1
				else
					rm -f "$SQLDBFILE.tmp" # Remove the temp file.
					chmod u=wr,g-rwx,o-wrx "$SQLDBFILE" # Set reasonable file permissions on the DB file.
				fi
				# Validate the downloaded DB.
				f_validate_db ; X_DB_VALIDATE_POSTDOWNLOAD=$?
				if [[ "$X_DB_VALIDATE_POSTDOWNLOAD" == 0 ]] ; then
					echo ""
					echo "DB file downloaded and validated successfully."
					break
				elif [[ "$X_DB_VALIDATE_POSTDOWNLOAD" == 2 ]] ; then
					# Hopefully I upload a new sample DB every time I update the DB, but just in case.
					f_update_db ; X_DB_POSTDOWNLOAD_UPDATE=$?
					if [[ "$X_DB_POSTDOWNLOAD_UPDATE" == 0 ]] ; then break ; else return 1 ; fi
				else
					echoerr ""
					echoerr "ERROR: Post-download DB validation failed."
					echoerr ""
					return 1
				fi
			elif [[ "$DB_OPT" == "NEW" ]] ; then
				echo ""
				echo -n "Creating a new DB file... "
				touch "$SQLDBFILE"
				chmod u=wr,g-rwx,o-wrx "$SQLDBFILE"
				# We will create a version 1 database with apropriate tables.
				$SQLCMD "CREATE TABLE dbinfo(DB_VER);"
				$SQLCMD "INSERT INTO "dbinfo" VALUES('1');"
				$SQLCMD "CREATE TABLE srcinfo(GAMETYPE UNIQUE NOT NULL PRIMARY KEY, GAMENAME NOT NULL, UPDATER, HLDSID, SERVER_APPID, CLIENT_APPID, GAMEARG, BINDIRSUBD, STEAMINF, INSTDEF_IPADDR, INSTDEF_CLIENTPORT, INSTDEF_HOSTPORT, INSTDEF_TVPORT, INSTDEF_STEAMPORT, INSTDEF_ALLOWUPDATE default '0', INSTDEF_ALLOWSTART, INSTDEF_BOOTSTART, INSTDEF_AUTOCLEANUP, INSTDEF_MAILNOTIFY, INSTDEF_MAILTO, INSTDEF_RECOVER_CRASH_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL default '10', INSTDEF_RECOVER_WATCHDOG_POLL_MAX default '6', INSTDEF_RECOVER_WATCHDOG_START_WAIT default '60', INSTDEF_RECOVER_SLEEP default '10', INSTDEF_STARTBIN, INSTDEF_STARTBINARGS);"
				$SQLCMD "CREATE TABLE inst(INSTALLID UNIQUE NOT NULL PRIMARY KEY, GAMETYPE NOT NULL, INSTTYPE NOT NULL, IPADDR, CLIENTPORT, HOSTPORT, TVPORT, STEAMPORT, ALLOWUPDATE default '0', ALLOWSTART default '0', BOOTSTART default '0', AUTOCLEANUP default '0', MAILNOTIFY default '0', MAILTO default '', RECOVER_CRASH_ENABLE default '0', RECOVER_WATCHDOG_ENABLE default '0', RECOVER_WATCHDOG_TEST_INTERVAL default '', RECOVER_WATCHDOG_POLL_MAX default '', RECOVER_WATCHDOG_START_WAIT default '', RECOVER_SLEEP default '', STARTBIN default 'srcds_run', STARTBINARGS default '');"
				echo "Done"
				break
			fi
		done
	elif [[ "$X_VALIDATE_DB" == 2 ]] ; then
		# Upgrade as necessary.
		f_update_db || return 1
	elif ! [[ "$X_VALIDATE_DB" == 0 ]] ; then
		# Nonzero status is an error.
		return 1
	fi
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# Verify SteamCMD is installed where it should be.
	echo ""
	echo "--"
	echo ""
	echo "We will now verify that SteamCMD is installed, or install it if necessary."
	echo ""
	echo "VERIFICATION: Shall we continue?"
	read -e -r -p "y/N: " -i "" REPLY
	if [[ ! "$REPLY" == [yY] ]]; then
		echo ""
		echo "Quitting."
		echo ""
		return 0
	fi
	echo ""
	if [[ -x "$STEAMCMD_BIN" ]] ; then
		echo "SteamCMD found successfully: $STEAMCMD_BIN."
	else
		STEAMCMD_INSTALLER_URL="http://media.steampowered.com/installer/steamcmd_linux.tar.gz"
		echo "SteamCMD not found. Do you want to install SteamCMD now?"
		echo "  SteamCMD will be installed in $STEAMCMD_BIN"
		echo ""
		read -e -r -p "y/N: " -i "" REPLY
		if [[ ! "$REPLY" == [yY] ]]; then
			echo ""
			echo "SteamCMD must be installed to use $MYNAME."
			echo "Quitting."
			echo ""
			return 0
		fi
		# FIXME: This is junk. I got lazy. I'll fix it some day.
		mkdir -p ~/bin/steamcmd || { echoerr "ERROR: Unable to create steamcmd dir!" ; return 1 ; }
		wget --timeout=30 --tries=3 -O ~/bin/steamcmd/steamcmd_linux.tar.gz "$STEAMCMD_INSTALLER_URL" &> /dev/null || {
			echoerr "ERROR: SteamCMD download failed. Try again later?" ; return 1 ; }
		tar -xzf ~/bin/steamcmd/steamcmd_linux.tar.gz -C ~/bin/steamcmd/ || { echoerr "ERROR: Extracting the SteamCMD archive failed." ; return 1 ; }
		#
		# Verify that SteamCMD got installed correctly.
		if [[ ! -x "$STEAMCMD_BIN" ]] ; then
			echoerr ""
			echoerr "ERROR: SteamCMD install failed. Unable to execute."
			echoerr ""
			return 1
		else
			echo ""
			echo "SteamCMD installed successfully."
		fi
	fi
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	#
	# Bash auto-completion script notice.
	echo ""
	echo "--"
	echo ""
	echo "$MYNAME offers a bash-autocompletion script. This enables command tab-completion of wrench arguments."
	echo "  On some system, you can simply append the contents of the bash-completion script to your ~/.bash_completion file."
	echo "  Otherwise, just append the file contents to your bash profile (.profile, .bash_profile, etc)."
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# Renice notice.
	echo ""
	echo "--"
	echo ""
	echo "$MYNAME uses nice/renice to change the run priority of running installations."
	echo "  Renicing the srcds process can prevent performance problems caused by local load."
	echo "  Unfortunately, this requires user configuration in /etc/security/limits.conf."
	echo "  You will need to manually configure this if you want your srcds processes to be reniced."
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# cron items notice.
	echo ""
	echo "--"
	echo ""
	echo "For the autoupdate and autocleanup features to work, you must add an entry to your cron tab."
	echo "  Examples have been listed below, where autoupdate will be run every five minutes, and autocleanup "
	echo "  will be run each day at 0500 local time: "
	echo ""
	echo '  */5 * * * *      ~/bin/wrench autoupdate 1> /dev/null'
	echo '  0 5 * * *      ~/bin/wrench autocleanup 1> /dev/null'
	echo ""
	echo "  Also, you may wish to configure your servers to automatically start after a system boot:"
	echo ""
	echo '  @reboot       ~/bin/wrench bootstart'
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# Mail configuration notice.
	echo ""
	echo "--"
	echo ""
	echo "wrench sends email/hipchat notifications for important events. Be sure to configure your host to send email and set MAILTO as apropriate."
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# Firewall notice.
	echo ""
	echo "--"
	echo ""
	echo "If you have a firewall (and you should), be sure to allow inbound and outbound traffic for srcds."
	echo "  This script won't help you with configuring your firewall."
	echo ""
	read -r -s -p "Press ENTER to continue." ; echo ""
	#
	# All done.
	echo ""
	echo "--"
	echo ""
	echo "Setup completed!"
	echo ""
	echo "You should now be able to install a new srcds installation. Use the \"$MYNAME install\" command to do so."
	echo ""
	return 0
}

f_runwatchdog() {
	# A watchdog process used in wrench_run mode.
	# The watchdog exists to recover from when the SRCDS_LINUX process is still running, but has seized up.
	#
	# The watchdog requires certain env vars. If we don't have them, quit.
	# See EXPORT_VARS in f_start for what is being exported to wrench_run.
	for EACH in INSTALLDIR PIDFILE IPADDR HOSTPORT RECOVER_CRASH_ENABLE RECOVER_WATCHDOG_ENABLE RECOVER_WATCHDOG_TEST_INTERVAL RECOVER_WATCHDOG_POLL_MAX RECOVER_WATCHDOG_START_WAIT RECOVER_SLEEP; do
		if [[ -z "$EACH" ]] ; then # FIXME: Would like to use test -v here, but not portable.
			echoerr "$MYNAME: ERROR: environmental requirement \"$EACH\" not found."
			ENV_ERROR=1
		fi
	done ; unset EACH
	if [[ "$ENV_ERROR" == 1 ]] ; then
		echoerr ""
		echoerr "$MYNAME watchdog: ERROR: At least one required envrionmental variable is missing."
		echoerr ""
		return 1
	fi
	#
	# qstat is required.
	if [[ "$QSTAT_MISSING" == 1 ]] ; then
		echoerr "$MYNAME watchdog: Watchdog disabled because qstat could not be found."
		return 1
	fi
	#
	declare -i WATCHDOG_FAILCOUNT=0
	# Don't do anything until the server has been up at least this long.
	echo "$MYNAME watchdog: Waiting $RECOVER_WATCHDOG_START_WAIT seconds on startup before monitoring begins."
	sleep "$RECOVER_WATCHDOG_START_WAIT"
	echo "$MYNAME watchdog: Finished startup wait, begin monitoring server."
	#
	# FIXME: It might be better to background the job inside of the watchdog function instead of outside of it.
	while true ; do
		f_getpid ; X_GETPID=$?
		#
		# Watchdog should only be running if the SRCDS_LINUX process is running. Otherwise, quit. This is a safeguard.
		if [[ ! "$RUNSTATUS" == "running" ]] ; then
			echo "$MYNAME watchdog: Watchdog can't find process to watch. Quitting."
			return 0
		fi
		#
		# FIXME: Not sure if monitoring for "DOWN" reply is apropriate here.
		if ( f_qstat -retry 1 -nh -a2s "$IPADDR":"$HOSTPORT" | egrep "^$IPADDR:$HOSTPORT no response$|^$IPADDR:$HOSTPORT       DOWN$" &> /dev/null ) ; then
			WATCHDOG_FAILCOUNT=$(( $WATCHDOG_FAILCOUNT + 1 ))
			echo "$MYNAME watchdog: Server did not respond to query. Failure count: $WATCHDOG_FAILCOUNT."
		else
			# echo "$MYNAME watchdog: Server responding. Looks good."
			WATCHDOG_FAILCOUNT=0
		fi
		# If our fail counter gets reached, we need to kill the process, because it's seized up.
		if [[ "$WATCHDOG_FAILCOUNT" == "$RECOVER_WATCHDOG_POLL_MAX" ]] ; then
			echoerr "$MYNAME watchdog: Server appears to be seized up. Killing it to cause a restart/exit."
			if [[ "$X_GETPID" == "0" ]] ; then
				# We kill the process, since it is almost certainly not going to respond to any other signal.
				kill -SIGKILL "$GAMESERVPID"
				# We did our job, now quit.
				echo "$MYNAME watchdog: Watchdog quitting post-kill."
				return 0
			else
				echo "$MYNAME watchdog: Unable to get PID; unable to kill process. Watchdog quitting on error."
				return 1
			fi
		fi
		sleep "$RECOVER_WATCHDOG_TEST_INTERVAL"
	done ; unset WATCHDOG_FAILCOUNT
}

f_stopwatchdog() {
	# Stop the watchdog process, if it is running.
	if [[ "$WATCHDOG_RUNNING" == 1 ]] && ( ps --no-headers -p $X_WATCHDOG_PID -o pid &> /dev/null ) ; then
		echo -n "$MYNAME: Stopping watchdog: "
		# kill -TERM "$X_WATCHDOG_PID" &> /dev/null
		kill -TERM "$X_WATCHDOG_PID" &> /dev/null
		wait "$X_WATCHDOG_PID" 2> /dev/null # This wait is here to supress job termination notifications.
		WATCHDOG_RUNNING=0
		echo "Done"
	fi
}

f_wrenchrun() {
	# wrench run (wrench_run) mode is a replacement for srcds_run.
	#
	# $1 must be "run" to run this func. This should be impossible to screw up, but whatever.
	if ! [[ "$1" == "run" ]] ; then
		echoerr ""
		echoerr "ERROR: The first argument for run mode must be \"run\"."
		echoerr "  This should never happen. Something is seriously wrong."
		echoerr ""
		return 1
	else
		# Remove "run" as $1 and move everything else over.
		shift
	fi
	#
	# srcds_run compatability: Set a number of vars based on what srcds_linux probably expects.
	WRENCHRUN_PARAMS=$*
	# echoerr "DEBUG: wrench run startup envrionment (via printenv): " ; printenv ; echoerr ""
	export LD_LIBRARY_PATH="$INSTALLDIR:$INSTALLDIR/bin:$LD_LIBRARY_PATH"
	GAME="$GAMEARG" # Possibly overwritten later by -game
	umask 002 # Needed for a local web server to serve replay files.
	#
	# Set certain envrionment vars based on stdin. This is mostly for compatability with srcds_run.
	while [[ "$#" -gt 0 ]] ; do
		case "$1" in
			'-h'|'--help')
				f_wrenchrun_commandhelper
			;;
			'+map')
				MAP="$2"
				shift 2
			;;
			'-game')
				GAME="$2"
				shift 2
			;;
			'-pidfile')
				PID_FILE="$2" ; PID_FILE_SET=1
				shift 2
			;;
			'-debug')
				DEBUG=1
				shift
			;;
			'-ignoresigint')
				IGNORE_INT=1
				shift
			;;
		esac
		shift
	done
	#
	echo ""
	echo "$MYNAME: Starting installation \"$INSTALLID\"."
	echo "$MYNAME: Startup parameters: \"$WRENCHRUN_PARAMS\""
	echo ""
	#
	# Verify that we have required envrionmental variables.
	# See EXPORT_VARS in f_start for what is being exported to wrench_run.
	for EACH in INSTALLDIR PIDFILE GAMEARG GAME RECOVER_CRASH_ENABLE RECOVER_WATCHDOG_ENABLE RECOVER_WATCHDOG_TEST_INTERVAL RECOVER_WATCHDOG_POLL_MAX RECOVER_WATCHDOG_START_WAIT RECOVER_SLEEP; do
		if [[ -z "$EACH" ]] ; then # FIXME: Would like to use test -v here, but not portable.
			echoerr "$MYNAME: ERROR: environmental requirement \"$EACH\" not found."
			ENV_ERROR=1
		fi
	done ; unset EACH
	if [[ "$ENV_ERROR" == 1 ]] ; then
		echoerr ""
		echoerr "$MYNAME: ERROR: At least one required envrionmental variable is missing."
		echoerr ""
		return 3
	fi
	#
	# $PWD must be $INSTALLDIR; verify.
	cd $INSTALLDIR &> /dev/null
	if ! [[ "$(pwd)" == "$INSTALLDIR" ]] ; then
		echoerr ""
		echoerr "$MYNAME: ERROR: The working directory must be INSTALLDIR to run $MYNAME, but is not."
		echoerr "  INSTALLDIR=$INSTALLDIR"
		echoerr "  PWD=$(pwd)"
		echoerr ""
		return 1
	fi
	#
	# PID_FILE and PIDFILE are possibly different. PID_FILE comes from the -pidfile argument, and PIDFILE is generated automatically in wrench.
	# However, these must be the same, or else it's an error. Usually, a user should just specify "-pidfile $PIDFILE" in the STARTUPARGS.
	# This will catch a user who has removed -pidfile or broken it.
	if [[ -z "$PID_FILE_SET" ]] ; then
		echoerr ""
		echoerr "$MYNAME: ERROR: -pidfile is missing from STARTBINARGS."
		echoerr "  The -pidfile argument is required for the startup arguments to pass to $SRCDS_LINUX."
		echoerr "  Add the following to your STARTBINARGS to fix this: \"-pidfile \$PIDFILE\""
		echoerr ""
		return 1
	fi
	if ! [[ "$PIDFILE" == "$PID_FILE" ]] ; then
		echoerr ""
		echoerr "$MYNAME: ERROR: the -pidfile argument is invalid."
		echoerr "  The -pidfile argument must be \"\$PIDFILE\"."
		echoerr""
		return 1
	fi
	#
	# Error if a directory within INSTALLDIR does not match up to GAMEARG/GAME.
	if ! [[ -d "$GAME" ]] ; then
		echoerr ""
		echoerr "$MYNAME: ERROR: GAME parameter \"$GAME\" does not match a directory within the INSTALLDIR."
		echoerr "  Are you trying to start the correct game type for this installation?"
		echoerr "  GAMEARG=\"$GAMEARG\", GAME=\"$GAME\""
		echoerr ""
		return 1
	fi
	#
	# Note if +map is not given on the startup command. Not required, but often an issue.
	if [[ -z "$MAP" ]] ; then
		echo "$MYNAME: No map specified in startup arguments."
	fi
	#
	# If our host allows us to raise the process priority when starting SRCDS_LINUX, we should do that.
	if (egrep "$USER.*nice" /etc/security/limits.conf &> /dev/null) ; then
		WRENCHRUN_NICEOPTS="nice -n -10 ionice -c 2 -n 2"
	else
		WRENCHRUN_NICEOPTS=""
	fi
	#
	# Ignore SIGINT, which is what happens when you do ctrl+c.
	if [[ "$IGNORE_INT" == 1 ]] ; then
		trap "" SIGINT
		trap f_wrenchrun_cleanuptrap SIGHUP SIGQUIT SIGABRT
	else
		trap f_wrenchrun_cleanuptrap SIGHUP SIGINT SIGQUIT SIGABRT
	fi
	# Set up the crash counter array.
	declare -A ar_CRASHES
	declare -i CRASH_COUNTER ABSOLUTE_MAX_CRASH_COUNTER
	#
	# --
	#
	# Run the srcds binary program.
	while true ; do
		# Run the watchdog if it is enabled.
		if [[ "$RECOVER_WATCHDOG_ENABLE" == 1 ]] ; then
			f_runwatchdog & X_WATCHDOG_PID="$!"
			WATCHDOG_RUNNING=1
			echo "$MYNAME watchdog: Started watchdog process at PID: $X_WATCHDOG_PID."
		else
			echo "$MYNAME watchdog: RECOVER_WATCHDOG_ENABLE disabled. Not starting watchdog."
		fi
		#
		echo "$MYNAME: Executing $SRCDS_LINUX."
		$WRENCHRUN_NICEOPTS ./$SRCDS_LINUX $WRENCHRUN_PARAMS ; X_SRCDS_LINUX=$?
		f_stopwatchdog # We must stop the watchdog as soon as SRCDS_LINUX exits, no matter why it quit.
		if [[ "$X_SRCDS_LINUX" == 0 ]] ; then
			# Exit 0 is caused by issuing "quit" on the console.
			echo "$MYNAME: $SRCDS_LINUX quit normally, exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		elif [[ "$X_SRCDS_LINUX" == 129 ]] ; then
			echo "$MYNAME: $SRCDS_LINUX quit on SIGHUP(1), exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		elif [[ "$X_SRCDS_LINUX" == 130 ]] ; then
			# ctrl+c on console is SIGINT.
			echo "$MYNAME: $SRCDS_LINUX quit on SIGINT(2), exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		elif [[ "$X_SRCDS_LINUX" == 131 ]] ; then
			echo "$MYNAME: $SRCDS_LINUX quit on SIGQUIT(3), exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		elif [[ "$X_SRCDS_LINUX" == 134 ]] ; then
			echo "$MYNAME: $SRCDS_LINUX quit on SIGABRT(6), exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		elif [[ "$X_SRCDS_LINUX" == 143 ]] ; then
			echo "$MYNAME: $SRCDS_LINUX quit on SIGTERM(15), exit code: $X_SRCDS_LINUX."
			f_wrenchrun_cleanup
			break
		else
			# Anything else is a crash.
			NEW_CRASHID="$(date +%s)" # Epoch seconds.
			CRASH_CAPTURE_PANE_FILE="$INSTALLDIR/crash_capture-pane_$(date +%Y%m%d%H%M%S)-$$.log" # FIXME: Not sub-second safe.
			#
			# A SIGKILL is special. This is how we force a seized/hung process to stop. It's still a type of crash though.
			# A kill could come from the watchdog, but it could also come from elsewhere, so we can't be certain of the intent.
			# FIXME: We can pipe back a signal from the watchdog process, I suppose.
			if [[ "$X_SRCDS_LINUX" == 137 ]] ; then
			 	echoerr "$MYNAME: $SRCDS_LINUX killed on SIGKILL(9), exit code: $X_SRCDS_LINUX."
				f_mailnotify crash "Server quit on SIGKILL(9), exit code: $X_SRCDS_LINUX."
			else
				echoerr "$MYNAME: $SRCDS_LINUX crashed with exit code: $X_SRCDS_LINUX"
				f_mailnotify crash "Server crashed, exit code: $X_SRCDS_LINUX. Crash log: $CRASH_CAPTURE_PANE_FILE"
			fi
			#
			# Write the recent tmux window pane history to a file, so that that it can be reviewed later.
			echoerr "$MYNAME: Saving recent tmux window pane history to file: $CRASH_CAPTURE_PANE_FILE"
			# FIXME: Why does the following line not work? It works if the TMUX_CAPTURE_OPTS parameter is not quoted.
			# tmux capture-pane "$TMUX_CAPTURE_OPTS" -t "$INSTALLID":0.0 \; save-buffer "$CRASH_CAPTURE_PANE_FILE"
			tmux capture-pane $TMUX_CAPTURE_OPTS -t "$INSTALLID":0.0 \; save-buffer "$CRASH_CAPTURE_PANE_FILE"
			#
			# If crash recovery is disabled via RECOVER_CRASH_ENABLE, stop here and don't restart.
			if [[ ! "$RECOVER_CRASH_ENABLE" == 1 ]] ; then
				echoerr "$MYNAME: Crash recovery disabled. Will not restart."
				f_wrenchrun_cleanup
				break
			fi
			#
			# Stop a running installation if it crashes too often.
			ar_CRASHES["$NEW_CRASHID"]="$NEW_CRASHID" # Append the current crash ID to the crashes array.
			declare -i CRASH_COUNTER=0 # FIXME: Could use ${#ar_CRASHES[@]} instead.
			for EACH in "${ar_CRASHES[@]}" ; do
				# echoerr "DEBUG: Processing crash ID $EACH"
				# Find out if the current crash ID is within the limit window, and count it towards the limit max if so.
				if [[ "$(( $NEW_CRASHID - $EACH ))" -le "$RECOVER_LIMIT_WINDOW" ]] ; then
					CRASH_COUNTER=$(( CRASH_COUNTER + 1))
					# echoerr "DEBUG: Added $EACH to crash count."
				else
					# Remove old crashes from the array.
					unset ar_CRASHES[$EACH]
					# echoerr "DEBUG: Removed old $EACH from crash array."
				fi
			done ; unset EACH
			# echoerr "DEBUG: Crash array list is: $(echo "${ar_CRASHES[@]}" | tr '\n' ' ')"
			# If we have reached the maximum number of crashes allowed in this time window, we should not recover.
			if [[ "$CRASH_COUNTER" -ge "$RECOVER_LIMIT_MAX" ]] ; then
				echoerr "$MYNAME: Crash limit reached. $CRASH_COUNTER crashes within $RECOVER_LIMIT_WINDOW seconds. Will not restart."
				f_wrenchrun_cleanup
				break
			fi
			#
			# The absolute max crash protection routine below is mostly for people who disable the regular crash limiter above.
			ABSOLUTE_MAX_CRASH_COUNTER=$(( ABSOLUTE_MAX_CRASH_COUNTER + 1))
			if [[ "$ABSOLUTE_MAX_CRASH_COUNTER" -gt "$RECOVERY_ABSOLUTE_MAX" ]] ; then
				echoerr "$MYNAME: Absolute maximum number of crashes reached. Will not restart."
				f_wrenchrun_cleanup
				break
			fi
			#
			echoerr "$MYNAME: Restarting in $RECOVER_SLEEP seconds. Total crashes: $ABSOLUTE_MAX_CRASH_COUNTER"
			sleep "$RECOVER_SLEEP"
			echoerr ""
			continue
		fi
	done ; unset X_WATCHDOG_PID X_SRCDS_LINUX WATCHDOG_RUNNING CRASH_CAPTURE_PANE_FILE NEW_CRASHID ar_CRASHES CRASH_COUNTER ABSOLUTE_MAX_CRASH_COUNTER
	#
	echo ""
	echo "$MYNAME: Quitting."
	echo ""
	# DEBUG_CAPTURE_PANE_FILE="$INSTALLDIR/debug_capture-pane_$(date +%Y%m%d%H%M%S)-$$.log"
	# tmux capture-pane "$TMUX_CAPTURE_OPTS" -t "$INSTALLID":0.0 \; save-buffer "$DEBUG_CAPTURE_PANE_FILE"
	sleep 1 # Sleep a second. This helps f_start figure out what went wrong on failed startups.
}

f_mailnotify() {
	# Mail notifications.
	#
	local MAIL_TOPIC MAIL_MESSAGE
	#
	# Uncomment this to disable email notifications during testing.
	# echoerr "DEBUG: Mail notifications disabled." ; MAILNOTIFY=disabled
	#
	MAIL_TOPIC="$1"
	MAIL_MESSAGE="$2"
	# We need a MAIL_TOPIC
	if [[ ! -n "$MAIL_TOPIC" ]] ; then
		echoerr ""
		echoerr "ERROR: Mail notification called, but no topic specified."
		echoerr ""
		return 1
	fi
	# Only send mail if MAILNOTIFY is set.
	if [[ "$MAILNOTIFY" == 1 ]] ; then
		$MAILER -s "$MAIL_SUBJ_PREFIX $INSTALLID $MAIL_TOPIC " $MAILTO <<-ENDMESSAGE
			
			Date: $(date)
			Server: $INSTALLID
			Action: $MAIL_TOPIC (Called via: $IN_ARG)
			Message: $MAIL_MESSAGE

		ENDMESSAGE
	fi

    if [[ "$HIPCHATNOTIFY" == 1 ]] ; then
		if [[ "$MAIL_TOPIC" == *"crash"* ]] ; then
			curl -sS -H 'Content-type: application/json' -d "{\"color\":\"red\", \"message\":\"$INSTALLID: $MAIL_TOPIC - $MAIL_MESSAGE\", \"message_format\":\"html\",\"notify\":\"true\"}" https://api.hipchat.com/v2/room/$HIPCHAT_ROOM/notification?auth_token=$HIPCHAT_TOKEN
		else
			curl -sS -H 'Content-type: application/json' -d "{\"color\":\"green\", \"message\":\"$INSTALLID: $MAIL_TOPIC - $MAIL_MESSAGE\", \"message_format\":\"html\"}" https://api.hipchat.com/v2/room/$HIPCHAT_ROOM/notification?auth_token=$HIPCHAT_TOKEN
		fi
	fi
}

f_validate_1arg() {
	# If this is a single-argument command trying to use more arguments when it should not, print a specific error.
	if [[ "$IN_PARAMS_NUM" -gt 1 && " ${IN_PARAMS1[@]}" =~ "${IN_ARG} " ]] ; then
		echoerr ""
		echoerr "ERROR: Action argument \"$IN_ARG\" does not accept any sub-arguments."
		echoerr ""
		return 1
	fi
}

f_validate_installid() {
# Validate arguments where not more or less than one INSTALLID target is requried.
    if [[ "$IN_PARAMS_NUM" -lt 3 && " ${IN_PARAMS3[@]} " =~ " ${IN_ARG} " &&  $IN_PARAMS != *"force" ]] ; then
        echoerr ""
        echoerr "Too few arguments! Minimum of 4 arguments to \"$IN_ARG\" is accepted."

        echoerr "here: $IN_PARAMS"

        echoerr ""
        return 1
    fi
	if [[ "$IN_PARAMS_NUM" -gt 2 && " ${IN_PARAMS2[@]}" =~ "${IN_ARG} " &&  $IN_PARAMS != *"force" ]] ; then
		echoerr ""
		echoerr "Too many arguments! Only a single argument to \"$IN_ARG\" is accepted."
		
		echoerr "here: $IN_PARAMS"

		echoerr ""
		return 1
	fi
    if [[ "$IN_PARAMS_NUM" -lt 2 ]] ; then
		echoerr ""
		echoerr "ERROR: This command requires a second argument, which should be an installation ID."
		echoerr "  What installation do you want to \"$IN_ARG\"?"
		echoerr ""
		return 1
	fi
	# If IN_INSTALLID has any trailing slashes, due to shell autocompletion, remove it
	if (echo "$IN_INSTALLID" | egrep "+*/$" &> /dev/null) ; then
		# echo "DEBUG: Trimming trailing slash on input."
		IN_INSTALLID=$(echo "$IN_INSTALLID" | tr -d '/')
	fi
	# Test the DB to see if there is a valid installation by that name.
	if ! [[ "$($SQLCMD "select INSTALLID from inst where INSTALLID='$IN_INSTALLID';")" == "$IN_INSTALLID" ]] ; then
		echoerr ""
		echoerr "ERROR: Installation ID \"$IN_INSTALLID\" not found in the database."
		echoerr ""
		return 1
	fi
	# If we are doing something to an install, there should be a directory there.
	if [[ ! -d "$APPDIR/$IN_INSTALLID" ]] ; then
		echoerr ""
		echoerr "ERROR: No directory for installation \"$IN_INSTALLID\" found!"
		echoerr ""
		return 1
	fi
}

f_dbup_0-to-1() {
	# Update the wrench SQL database from version 0 to 1.
	#
	# This is the old database used with wrench versions v1.32 and prior, which did not have a dbinfo table, therefore we call it database version "0".
	echo -n "Updating the DB version from 0 to 1... "
	# Test for the GAMEARG column. If it's not there, add it with some data.
	# SQL does conditional evaluation via CASE WHEN, but I'm dumb so let's use bash for now.
	$SQLCMD "select GAMEARG from srcinfo;" &> /dev/null || $SQLCMD <<- ENDSQL
		begin transaction;
		alter table srcinfo add column GAMEARG;
		update srcinfo set GAMEARG="csgo" where GAMETYPE="csgo";
		update srcinfo set GAMEARG="cstrike" where GAMETYPE="css";
		update srcinfo set GAMEARG="fof" where GAMETYPE="fof";
		update srcinfo set GAMEARG="hl2mp" where GAMETYPE="hl2dm";
		update srcinfo set GAMEARG="left4dead" where GAMETYPE="l4d";
		update srcinfo set GAMEARG="left4dead2" where GAMETYPE="l4d2";
		update srcinfo set GAMEARG="tf" where GAMETYPE="tf2";
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	# Add the wrench_run watchdog columns if needed.
	$SQLCMD "select RECOVER_CRASH_ENABLE from inst;" &> /dev/null || $SQLCMD <<- ENDSQL
		begin transaction;
		alter table inst add column RECOVER_CRASH_ENABLE default '0';
		alter table inst add column RECOVER_WATCHDOG_ENABLE default '0';
		alter table inst add column RECOVER_WATCHDOG_TEST_INTERVAL default '';
		alter table inst add column RECOVER_WATCHDOG_POLL_MAX default '';
		alter table inst add column RECOVER_WATCHDOG_START_WAIT default '';
		alter table inst add column RECOVER_SLEEP default '';
		update inst set RECOVER_CRASH_ENABLE="1";
		update inst set RECOVER_WATCHDOG_ENABLE="1";
		update inst set RECOVER_WATCHDOG_TEST_INTERVAL="10";
		update inst set RECOVER_WATCHDOG_POLL_MAX="6";
		update inst set RECOVER_WATCHDOG_START_WAIT="60";
		update inst set RECOVER_SLEEP="10";
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	# If the old REPLAYPORT column exists on inst, remove it.
	# This is complicated because sqlite does not support ALTER TABLE commands to remove columns.
	$SQLCMD "select REPLAYPORT from inst;" &> /dev/null && $SQLCMD <<- ENDSQL
		begin transaction;
		create temporary table temp_inst(INSTALLID UNIQUE NOT NULL PRIMARY KEY, GAMETYPE NOT NULL, INSTTYPE NOT NULL, IPADDR, CLIENTPORT, HOSTPORT, TVPORT, STEAMPORT, ALLOWUPDATE default '0', ALLOWSTART default '0', BOOTSTART default '0', AUTOCLEANUP default '0', MAILNOTIFY default '0', MAILTO default '', RECOVER_CRASH_ENABLE default '0', RECOVER_WATCHDOG_ENABLE default '0', RECOVER_WATCHDOG_TEST_INTERVAL default '', RECOVER_WATCHDOG_POLL_MAX default '', RECOVER_WATCHDOG_START_WAIT default '', RECOVER_SLEEP default '', STARTBIN default 'srcds_run', STARTBINARGS default '');
		insert into temp_inst select INSTALLID,GAMETYPE,INSTTYPE,IPADDR,CLIENTPORT,HOSTPORT,TVPORT,STEAMPORT,ALLOWUPDATE,ALLOWSTART,BOOTSTART,AUTOCLEANUP,MAILNOTIFY,MAILTO,RECOVER_CRASH_ENABLE,RECOVER_WATCHDOG_ENABLE,RECOVER_WATCHDOG_TEST_INTERVAL,RECOVER_WATCHDOG_POLL_MAX,RECOVER_WATCHDOG_START_WAIT,RECOVER_SLEEP,STARTBIN,STARTBINARGS from inst;
		drop table inst;
		create table inst(INSTALLID UNIQUE NOT NULL PRIMARY KEY, GAMETYPE NOT NULL, INSTTYPE NOT NULL, IPADDR, CLIENTPORT, HOSTPORT, TVPORT, STEAMPORT, ALLOWUPDATE default '0', ALLOWSTART default '0', BOOTSTART default '0', AUTOCLEANUP default '0', MAILNOTIFY default '0', MAILTO default '', RECOVER_CRASH_ENABLE default '0', RECOVER_WATCHDOG_ENABLE default '0', RECOVER_WATCHDOG_TEST_INTERVAL default '', RECOVER_WATCHDOG_POLL_MAX default '', RECOVER_WATCHDOG_START_WAIT default '', RECOVER_SLEEP default '', STARTBIN default 'srcds_run', STARTBINARGS default '');
		insert into inst select INSTALLID,GAMETYPE,INSTTYPE,IPADDR,CLIENTPORT,HOSTPORT,TVPORT,STEAMPORT,ALLOWUPDATE,ALLOWSTART,BOOTSTART,AUTOCLEANUP,MAILNOTIFY,MAILTO,RECOVER_CRASH_ENABLE,RECOVER_WATCHDOG_ENABLE,RECOVER_WATCHDOG_TEST_INTERVAL,RECOVER_WATCHDOG_POLL_MAX,RECOVER_WATCHDOG_START_WAIT,RECOVER_SLEEP,STARTBIN,STARTBINARGS from temp_inst;
		drop table temp_inst;
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	# If the old INSTDEF_REPLAYPORT column exists on srcinfo, remove it.
	# This is complicated because sqlite does not support ALTER TABLE commands to remove columns.
	$SQLCMD "select INSTDEF_REPLAYPORT from srcinfo;" &> /dev/null && $SQLCMD <<- ENDSQL
		begin transaction;
		create temporary table temp_srcinfo(GAMETYPE UNIQUE NOT NULL PRIMARY KEY, GAMENAME NOT NULL, UPDATER, HLDSID, SERVER_APPID, CLIENT_APPID, GAMEARG, BINDIRSUBD, STEAMINF, INSTDEF_IPADDR, INSTDEF_CLIENTPORT, INSTDEF_HOSTPORT, INSTDEF_TVPORT, INSTDEF_STEAMPORT, INSTDEF_ALLOWUPDATE default '0', INSTDEF_ALLOWSTART, INSTDEF_BOOTSTART, INSTDEF_AUTOCLEANUP, INSTDEF_MAILNOTIFY, INSTDEF_MAILTO, INSTDEF_RECOVER_CRASH_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL default '10', INSTDEF_RECOVER_WATCHDOG_POLL_MAX default '6', INSTDEF_RECOVER_WATCHDOG_START_WAIT default '60', INSTDEF_RECOVER_SLEEP default '10', INSTDEF_STARTBIN, INSTDEF_STARTBINARGS);
		insert into temp_srcinfo select GAMETYPE,GAMENAME,UPDATER,HLDSID,SERVER_APPID,CLIENT_APPID,GAMEARG,BINDIRSUBD,STEAMINF,INSTDEF_IPADDR,INSTDEF_CLIENTPORT,INSTDEF_HOSTPORT,INSTDEF_TVPORT,INSTDEF_STEAMPORT,INSTDEF_ALLOWUPDATE,INSTDEF_ALLOWSTART,INSTDEF_BOOTSTART,INSTDEF_AUTOCLEANUP,INSTDEF_MAILNOTIFY,INSTDEF_MAILTO,INSTDEF_RECOVER_CRASH_ENABLE,INSTDEF_RECOVER_WATCHDOG_ENABLE,INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL,INSTDEF_RECOVER_WATCHDOG_POLL_MAX,INSTDEF_RECOVER_WATCHDOG_START_WAIT,INSTDEF_RECOVER_SLEEP,INSTDEF_STARTBIN,INSTDEF_STARTBINARGS from srcinfo;
		drop table srcinfo;
		create table srcinfo(GAMETYPE UNIQUE NOT NULL PRIMARY KEY, GAMENAME NOT NULL, UPDATER, HLDSID, SERVER_APPID, CLIENT_APPID, GAMEARG, BINDIRSUBD, STEAMINF, INSTDEF_IPADDR, INSTDEF_CLIENTPORT, INSTDEF_HOSTPORT, INSTDEF_TVPORT, INSTDEF_STEAMPORT, INSTDEF_ALLOWUPDATE default '0', INSTDEF_ALLOWSTART, INSTDEF_BOOTSTART, INSTDEF_AUTOCLEANUP, INSTDEF_MAILNOTIFY, INSTDEF_MAILTO, INSTDEF_RECOVER_CRASH_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_ENABLE default '0', INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL default '10', INSTDEF_RECOVER_WATCHDOG_POLL_MAX default '6', INSTDEF_RECOVER_WATCHDOG_START_WAIT default '60', INSTDEF_RECOVER_SLEEP default '10', INSTDEF_STARTBIN, INSTDEF_STARTBINARGS);
		insert into srcinfo select GAMETYPE,GAMENAME,UPDATER,HLDSID,SERVER_APPID,CLIENT_APPID,GAMEARG,BINDIRSUBD,STEAMINF,INSTDEF_IPADDR,INSTDEF_CLIENTPORT,INSTDEF_HOSTPORT,INSTDEF_TVPORT,INSTDEF_STEAMPORT,INSTDEF_ALLOWUPDATE,INSTDEF_ALLOWSTART,INSTDEF_BOOTSTART,INSTDEF_AUTOCLEANUP,INSTDEF_MAILNOTIFY,INSTDEF_MAILTO,INSTDEF_RECOVER_CRASH_ENABLE,INSTDEF_RECOVER_WATCHDOG_ENABLE,INSTDEF_RECOVER_WATCHDOG_TEST_INTERVAL,INSTDEF_RECOVER_WATCHDOG_POLL_MAX,INSTDEF_RECOVER_WATCHDOG_START_WAIT,INSTDEF_RECOVER_SLEEP,INSTDEF_STARTBIN,INSTDEF_STARTBINARGS from temp_srcinfo;
		drop table temp_srcinfo;
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	# Update the DB version.
	$SQLCMD <<- ENDSQL
		begin transaction;
		create table dbinfo (DB_VER);
		insert into "dbinfo" values ('1');
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	#
	echo "Done"
}

f_dbup_1-to-2() {
	# Update the wrench SQL database from version 1 to 2.
	#
	local LIST_MASTERS
	#
	echo -n "Updating the DB version from 1 to 2... "
	# Add the INSTVER and INSTVER_METHOD column to inst to start tracking local versions in the wrench DB.
	$SQLCMD <<- ENDSQL
		begin transaction;
		alter table inst add column INSTVER;
		alter table inst add column INSTVER_METHOD;
		update inst set INSTVER='0' where INSTTYPE='master';
		update inst set INSTVER_METHOD='db' where INSTTYPE='master';
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	# For existing master installations, we import the steaminf local version into the db.
	# This will prevent a sudden need to update all installations just to set the INSTVER the the current version.
	LIST_MASTERS=$($SQLCMD "select INSTALLID from inst where INSTTYPE='master';") || return 1
	for EACH_MASTER in $LIST_MASTERS ; do
		IN_INSTALLID=$EACH_MASTER
		f_loaddbinst || return 1
		INSTVER_METHOD=steaminf ; f_getlocalver
		# echoerr "DEBUG: Setting $INSTALLID INSTVER to $LOCAL_VER from steaminf."
		$SQLCMD "update inst set INSTVER='$LOCAL_VER' where INSTALLID='$EACH_MASTER';" || return 1
	done ; unset EACH_MASTER
	# Update the DB version.
	$SQLCMD <<- ENDSQL
		begin transaction;
		update dbinfo set DB_VER='2';
		commit;
	ENDSQL
	if ! [[ $? == 0 ]] ; then return 1 ; fi
	echo "Done"
}

f_dbup_fail() {
	# If we fail a database update, we need to help the user revert to a working situation.
	echoerr ""
	echoerr "The database upgrade process has failed."
	echoerr ""
	echoerr "You should revert $MYNAME to the previous version, and restore your old database backup."
	echoerr "  The previous database prior to the failed update is here: $BACKUP_SQLDBFILE"
	echoerr ""
	return 1
}

f_update_db() {
	# Update the SQL database.
	#
	local BACKUP_SQLDBFILE X_UPDATE_DB_VALIDATE UPDATE_DB_LOOP_COUNTER
	#
	# First, make a backup.
	BACKUP_SQLDBFILE=$SQLDBFILE.bak-${RUNID}
	echo "Backing up the old DB to file: $BACKUP_SQLDBFILE"
	cp -ap "$SQLDBFILE" "$BACKUP_SQLDBFILE" || {
		echoerr ""
		echoerr "ERROR: Unable to make DB backup prior to update. Quitting."
		echoerr "  SQLDBFILE=$SQLDBFILE, BACKUP_SQLDBFILE=$BACKUP_SQLDBFILE"
		echoerr ""
		return 1
	}
	#
	declare -i UPDATE_DB_LOOP_COUNTER="0"
	while true ; do
		# While we want to loop though updates, it's possible to cause a runaway process. We will limit the maximum number of loops to prevent such problems.
		UPDATE_DB_LOOP_COUNTER=$(( $UPDATE_DB_LOOP_COUNTER + 1 ))
		if [[ "$UPDATE_DB_LOOP_COUNTER" -ge 20 ]] ; then
			echoerr ""
			echoerr "ERROR: Maximum number of DB update attempts reached."
			echoerr ""
			return 1
		fi
		# Only loop while the DB validator says that we still need to update.
		f_validate_db &> /dev/null ; X_UPDATE_DB_VALIDATE=$?
		if [[ "$X_UPDATE_DB_VALIDATE" == 0 ]] ; then
			# echoerr "DEBUG: Database fully updated."
			break
		elif ! [[ "$X_UPDATE_DB_VALIDATE" == 2 ]] ; then
			return 1
		fi
		#
		case "$DB_VER" in
			# This is where we make decisions about how to update each DB version to the next.
			# Run the dbup functions in subshells to isolate the main envrionment.
			'0')
				( f_dbup_0-to-1 ) || { f_dbup_fail ; return 1 ; }
			;;
			'1')
				( f_dbup_1-to-2 ) || { f_dbup_fail ; return 1 ; }
			;;
			*) # Anything else is unknown
				echoerr ""
				echoerr "ERROR: Unknown database version. Unable to upgrade!"
				echoerr ""
				return 1
		esac
	done ; unset UPDATE_DB_LOOP_COUNTER
}

f_validate_db() {
	# Validate the database. Return 0=valid, 1=error, 2=needs-update 3=no-file
	# Require the DB file to be present.
	#
	unset DB_VER DB_STATUS
	local X_DB_VER
	#
	# Obviously, if the file isn't there, that's a fail, except for setup. 
	if ! [[ -f "$SQLDBFILE" ]] ; then
		echoerr ""
		echoerr "ERROR: SQLDBFILE, \"$SQLDBFILE\" not found!"
		echoerr "  If you want to perform setup for the first time, run \"wrench setup\"."
		echoerr ""
		DB_STATUS=nofile
		return 3
	fi
	# Try to get the DB version.
	DB_VER=$($SQLCMD "select DB_VER from dbinfo;" 2> /dev/null) ; X_DB_VER=$?
	if ! [[ "$X_DB_VER" == 0 ]] ; then
		# Either this DB is invalid, SQLITE failed, or it's an old version 0 DB. We need to find out which it is.
		if [[ "$($SQLCMD '.tables' 2> /dev/null)" == "inst     srcinfo" ]] ; then
			# This is an old version 0 DB.
			DB_VER=0
		else
			# Whatever this is, we can't use it.
			unset DB_VER
			echoerr ""
			echoerr "ERROR: SQLITE exited $X_DB_VER while trying to get DB_VER. Database invalid?"
			echoerr ""
			DB_STATUS=error
			return 1
		fi
	fi
	# Now that we have a DB_VER, figure out what it means.
	if [[ "$DB_VER" == $"REQ_SQLDB_VER" ]] ; then # DB version is valid and compatible.
		# echoerr "DEBUG: DB version valid. REQ_SQLDB_VER=$REQ_SQLDB_VER, DB_VER=$DB_VER"
		DB_STATUS=valid
		return 0
	elif [[ "$DB_VER" -lt "$REQ_SQLDB_VER" ]] ; then # We need to update the DB.
		echoerr "" 
		echoerr "The $MYNAME database needs to be updated."
		echoerr ""
		DB_STATUS=update
		return 2
	elif [[ "$DB_VER" -gt "$REQ_SQLDB_VER" ]] ; then # This DB is from the future! Someone call the time police.
		echoerr ""
		echoerr "ERROR: The $MYNAME DB version is greater than the supported version."
		echoerr "  This version of $MYNAME can't support a newer DB. Update $MYNAME to the current version?"
		echoerr "  REQ_SQLDB_VER=$REQ_SQLDB_VER, DB_VER=$DB_VER"
		echoerr ""
		DB_STATUS=error
		return 1
	fi
}

f_wrenchrun_cleanuptrap() {
	# Cleanup trap.
	#
	echo ""
	echo "$MYNAME: Cleaning up: "
	f_wrenchrun_cleanup
	echo "$MYNAME: Cleanup done."
	echo ""
	exit 91
}

f_wrenchrun_commandhelper() {
	# Print this if input is nonsense or requests help.
	#
	echoerr ""
	echoerr "$MYNAME is a srcds_run replacement to be used with the wrench srcds control system."
	echoerr "  $MYNAME takes stdin and passes it directly on to the $SRCDS_LINUX binary, without modification."
	echoerr "  $MYNAME specific features are controled via parameters in the startup environment, as passed to it by wrench."
	echoerr ""
	echoerr "  For full documentation on wrench and $MYNAME, see the ${MYNAME}_README.txt file."
	echoerr ""
	exit 0
}

f_wrenchrun_cleanup() {
	# Stop the watchdog if it is running.
	f_stopwatchdog
	#
	# If the srcds_linux process is running, we want to pass signal on to it.
	# Most of the time, SRCDS_LINUX is already going to be dead by this point. This is for trapping a signal.
	f_getpid
	if ( [[ -n "$GAMESERVPID" ]] && [[ "$(ps --no-headers -p $GAMESERVPID -o comm 2> /dev/null)" == "$SRCDS_LINUX" ]] ) ; then
		echo -n "$MYNAME: Sending SIGINT to $SRCDS_LINUX, PID: $GAMESERVPID: "
		kill -s SIGINT "$GAMESERVPID"
		echo "Done"
	fi
	#
	# Delete the PIDFILE.
	# FIXME: is this even possible?
	if ( [[ -n "$PIDFILE" ]] && [[ -f "$PIDFILE" ]] ) ; then rm -f "$PIDFILE" || echoerr "$MYNAME: ERROR: Unable to remove PIDFILE!" ; fi
	if ( [[ -n "$PID_FILE_SET" ]] && [[ -f "$PID_FILE" ]] ) ; then rm -f "$PID_FILE" || echoerr "$MYNAME: ERROR: Unable to remove PID_FILE!" ; fi
}

f_help() {
	# Print some basic help info.
	SEEN_HELP=1
	echoerr ""
	echoerr "$MYNAME is a Source Dedicated Server (srcds) management tool for Valve's srcds-based game servers."
	echoerr ""
	echoerr "For more information, including full documentation, go here: "
	echoerr "  https://github.com/riemers/wrench"
	f_commandusage
}

f_commandusage() {
	# A quick print of valid commands.
	#
	echoerr ""
	echoerr "Single-argument commands:"
	for EACH in ${IN_PARAMS1[@]} ; do
		echoerr "  $MYNAME $EACH"
	done ; unset EACH
	echoerr ""
	echoerr "Server-specific commands:"
	for EACH in ${IN_PARAMS2[@]} ; do
		echoerr "  $MYNAME $EACH MyTarget"
	done ; unset EACH
        echoerr ""
        echoerr "Server-specific multi commands:"
        for EACH in ${IN_PARAMS3[@]} ; do
                echoerr "  $MYNAME $EACH MyTarget MyCommand"
        done
	if [[ ! "$SEEN_HELP" == 1 ]] ; then
		echoerr ""
		echoerr "Try \"$MYNAME help\" for more information."
	fi
	echoerr ""
}

#--

# If we are running an interactive shell (not cron), then save the terminal settings in case we trap and need to restore them.
# This is needed due to a bug in bash prior to 2015.
if (tty &> /dev/null) ; then
	# echo "DEBUG: Saved stty line settings."
	TTY_LINE_SETTINGS="$(stty -g 2> /dev/null)"
fi

trap 'f_cleanuptrap ; exit 90' SIGHUP SIGQUIT SIGABRT SIGTERM
trap 'f_cleanuptrap ; trap - SIGINT ; kill -s SIGINT $$' SIGINT
# trap f_cleanuptrap SIGHUP SIGQUIT SIGABRT SIGTERM SIGINT

IN_ARG="$1"
IN_INSTALLID="$2"
IN_PARAMS="$@"
IN_PARAMS_NUM="$#"

# A list of our single-argument and dual-argument commands.
# Note that there are also number of hidden input arguments, such as "run" and "gametype", plus aliases.
#  IN_PARAMS1 = single argument commands. No $2 possible.
#  IN_PARAMS2 = dual argument commands, $2 is required.
#  IN_PARAMS3 = multiple argument commands, $2, $3+ is required.
declare -a IN_PARAMS1=(install uninstall list listplayers autocleanup autoupdate bootstart stopall setup)
declare -a IN_PARAMS2=(start stop stopnow restart restartnow console status showconfig reconfig rename relink delink lockdown-master unlock-master cleanup update updatenow update-validate update-validatenow gametype)
declare -a IN_PARAMS3=(rcon)

# If "quakestat" is insatlled instead of qstat, use quakestat instead. quakestat comes from the debian qstat package.
if ! (type qstat &> /dev/null) && (type quakestat &> /dev/null) ; then
	# echoerr "DEBUG: Using quakestat in place of qstat."
	QSTAT_CMD=quakestat
else
	QSTAT_CMD=qstat
fi



# For anything other than initial setup or help, do some sanity checking.
if [[ -n "$IN_ARG" ]] && [[ ! "$IN_ARG" =~ ^setup$|^help$ ]] ; then
	# Require APPDIR to be present.
	if [[ ! -d "$APPDIR" ]] ; then
		echoerr ""
		echoerr "ERROR: APPDIR \"$APPDIR\" not found!"
		echoerr "  If you want to perform setup for the first time, use the \"setup\" argument."
		echoerr "  Be sure you have read the ${MYNAME}_README.txt file first!"
		echoerr ""
		exit 1
	fi
	# Validate the DB.
	f_validate_db ; X_VALIDATE_DB=$?
	if [[ "$X_VALIDATE_DB" == 2 ]] ; then
		# Upgrade as necessary.
		f_update_db || exit 1
	elif ! [[ "$X_VALIDATE_DB" == 0 ]] ; then
		# Nonzero status is an error.
		exit 1
	fi
	# If the steam and steamcmd.sh binaries are not found, we probably can't do installs or updates.
	# FIXME: Might want to turn this into a validation func; f_validate_steamcmd?
	if [[ ! -x "$STEAMCMD_BIN" ]] ; then
		echoerr ""
		echoerr "WARNING: Unable to find the SteamCMD installation."
		STEAMCMD_MISSING=1
	fi
	# Check for qstat; needed for wrench run, status, and listplayers at least.
	if ! (type -p "$QSTAT_CMD" &> /dev/null) ; then
		echoerr ""
		echoerr "WARNING: qstat/quakestat is missing."
		QSTAT_MISSING=1
	fi
fi

# This script is not multi-user safe because of eval usage. Test for go+w on SQLDBFILE.
EVAL_INSECURE=1 # Disable this test by setting this to 0.
if [[ "$EVAL_INSECURE" == 1 ]] && [[ -a "$SQLDBFILE" ]] && ( stat --format %A "$SQLDBFILE" | cut -c 6,9 | egrep "^w$" &> /dev/null ) ; then
	echoerr ""
	echoerr "ERROR: The SQLDBFILE is group and/or world writable. This is insecure."
	echoerr "  $MYNAME uses eval in ways which are a security risk if the DB file is writable by other users."
	echoerr "  Remove the offending permissions, or set EVAL_INSECURE=0 in $MYNAME."
	echoerr "  SQLDBFILE: $SQLDBFILE"
	echoerr ""
	exit 1
fi

# tmux related prereq work
if (type tmux &> /dev/null) ; then
	# Get the tmux version.
	TMUX_VER=$(tmux -V | egrep -o "[0-9].*[0-9]" 2> /dev/null)
	# NOTE: The default tmux scrollback buffer is limited to 2000 lines. Define "history-limit" in your ~/.tmux.conf to change this.
	# tmux capture-pane supports the -J argument from version 1.8 and on. This is very helpful. Use it if possible.
	TMUX_VER_GT18_REGEX="^1\.[8-9]$|^1\.[1-9][0-9]$|^[2-9]+" # We want to match versions > 1.8
	if [[ "$TMUX_VER" =~ $TMUX_VER_GT18_REGEX ]] ; then
		TMUX_CAPTURE_OPTS="-S - -J"
	else
		TMUX_CAPTURE_OPTS="-S -"
	fi
	# Require tmux version 1.6 or later. This is because of the epoll/libevent bug which caused redirection hangs.
	TMUX_VER_LT16_REGEX="^0\.[0-9]+|^1\.[0-5]$" # We want to match versions < 1.6
	if [[ "$TMUX_VER" =~ $TMUX_VER_LT16_REGEX ]] ; then
		echoerr ""
		echoerr "ERROR: $MYNAME requires tmux version 1.6 or later."
		echoerr ""
		exit 1
	fi
fi

# --

case "$IN_ARG" in
	'start')
		f_validate_installid || exit $?
		f_start
	;;
	'bootstart'|'startall')
		f_validate_1arg || exit $?
		f_bootstart
	;;
	'stop')
		f_validate_installid || exit $?
		f_stop
	;;
	'stopall')
		f_validate_1arg || exit $?
		f_stopall
	;;
	'stopnow')
		f_validate_installid || exit $?
		STOPNOW=yes
		f_stop
	;;
	'restart')
		f_validate_installid || exit $?
		f_stop
		sleep 1
		f_start
	;;
	'restartall')
		f_validate_1arg || exit $?
		f_stopall
		sleep 1
		f_bootstart
	;;
	'restartnow')
		f_validate_installid || exit $?
		STOPNOW=yes
		f_stop
		sleep 1
		f_start
	;;
	'listplayers')
		f_validate_1arg || exit $?
		f_listplayers
	;;
	'list')
		f_validate_1arg || exit $?
		f_listinstalls
	;;
	'status')
		f_allorone f_status || exit $?
	;;
	'autoupdate')
		f_validate_1arg || exit $?
		# This fixes our exec breaking trap problem, but now the pipeline breaks trap too, because the env isn't set.
		# We can fix our trap function by setting AUTOUPDATING=1 here before we even exec the func.
		# This causes new problems, such as the removal of logs on non-updates. Need to investigate further.
		AUTOUPDATING=1 ; f_autoupdate 2>&1 | tee $AUTOUPDATE_LOGFILE 
	;;
	'cleanup'|'clean')
		f_validate_installid || exit $?
		f_cleaninstall
	;;
	'update')
		f_validate_installid || exit $?
		f_update
	;;
	'updatenow')
		f_validate_installid || exit $?
		STOPNOW=yes
		f_update
	;;
	'update-validate'|'update-verify-all')
		f_validate_installid || exit $?
		VERIFYUPDATE=1
		f_update
	;;
	'update-validatenow'|'update-verify-all-now'|'update-validate-now')
		f_validate_installid || exit $?
		VERIFYUPDATE=1
		STOPNOW=yes
		f_update
	;;
	'relink')
		f_allorone f_relink || exit $?
	;;
	'delink')
		f_allorone f_delink || exit $?
	;;
	'console')
		f_validate_installid || exit $?
		f_tmuxattach
	;;
	'install')
		f_validate_1arg || exit $?
		f_install
	;;
	'uninstall')
		f_validate_1arg || exit $?
		f_uninstall
	;;
	'showconfig')
		f_allorone f_shownconfig || exit $?
	;;
    'rcon')
        f_allorone f_rcon $@ || exit $?
    ;;
	'reconfig')
		f_allorone f_reconfig || exit $?
		f_reconfig
	;;
	'rename')
		f_allorone f_rename || exit $?
	;;
	'lockdown-master'|'lock-master')
		f_validate_installid || exit $?
		f_lockdownmaster
	;;
	'unlock-master'|'unlockdown-master')
		f_validate_installid || exit $?
		f_unlockmaster
	;;
	'autocleanup'|'autoclean')
		f_validate_1arg || exit $?
		f_autocleanup
	;;
	'gametype')
		GAMETYPE_ARG="$2"
		case "$GAMETYPE_ARG" in
			'add'|'new'|'install'|'inst')
				GAMETYPE_ARG="add"
				f_changegametype
			;;
			'delete'|'del'|'rm')
				GAMETYPE_ARG="delete"
				f_deletegametype
			;;
			'change'|'modify'|'alter'|'reconfig')
				GAMETYPE_ARG="change"
				f_changegametype
			;;
			*)
				echoerr ""
				echoerr "Invalid sub-argument to gametype."
				echoerr ""
				exit 1
			;;
		esac
	;;
	'setup')
		f_validate_1arg || exit $?
		f_setup
	;;
	'run')
		# Note that "run" is special and may have many or no arguments.
		f_wrenchrun "$@"
	;;
	'--help'|'-help'|'help'|'-h')
		f_help
	;;
	*)
		echoerr ""
		echoerr "Invalid argument."
		f_commandusage
		exit 1
esac


